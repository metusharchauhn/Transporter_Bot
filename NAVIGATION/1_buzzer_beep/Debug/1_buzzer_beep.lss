
1_buzzer_beep.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000012  00800200  0000194a  000019de  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000194a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000018  00800212  00800212  000019f0  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000019f0  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001a20  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000218  00000000  00000000  00001a60  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000041f3  00000000  00000000  00001c78  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000ea5  00000000  00000000  00005e6b  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001a4a  00000000  00000000  00006d10  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000610  00000000  00000000  0000875c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000b9b  00000000  00000000  00008d6c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000313b  00000000  00000000  00009907  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000310  00000000  00000000  0000ca42  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 72 00 	jmp	0xe4	; 0xe4 <__ctors_end>
       4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
       8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
       c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      10:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      14:	0c 94 d7 01 	jmp	0x3ae	; 0x3ae <__vector_5>
      18:	0c 94 b2 01 	jmp	0x364	; 0x364 <__vector_6>
      1c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      20:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      24:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      28:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      2c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      30:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      34:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      38:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      3c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      40:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      44:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      48:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      4c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      50:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      54:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      58:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      5c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      60:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      64:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      68:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      6c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      70:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      74:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      78:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      7c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      80:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      84:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      88:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      8c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      90:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      94:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      98:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      9c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      a0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      a4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      a8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      ac:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      b0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      b4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      b8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      bc:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      c0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      c4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      c8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      cc:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      d0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      d4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      d8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      dc:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      e0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>

000000e4 <__ctors_end>:
      e4:	11 24       	eor	r1, r1
      e6:	1f be       	out	0x3f, r1	; 63
      e8:	cf ef       	ldi	r28, 0xFF	; 255
      ea:	d1 e2       	ldi	r29, 0x21	; 33
      ec:	de bf       	out	0x3e, r29	; 62
      ee:	cd bf       	out	0x3d, r28	; 61
      f0:	00 e0       	ldi	r16, 0x00	; 0
      f2:	0c bf       	out	0x3c, r16	; 60

000000f4 <__do_copy_data>:
      f4:	12 e0       	ldi	r17, 0x02	; 2
      f6:	a0 e0       	ldi	r26, 0x00	; 0
      f8:	b2 e0       	ldi	r27, 0x02	; 2
      fa:	ea e4       	ldi	r30, 0x4A	; 74
      fc:	f9 e1       	ldi	r31, 0x19	; 25
      fe:	00 e0       	ldi	r16, 0x00	; 0
     100:	0b bf       	out	0x3b, r16	; 59
     102:	02 c0       	rjmp	.+4      	; 0x108 <__do_copy_data+0x14>
     104:	07 90       	elpm	r0, Z+
     106:	0d 92       	st	X+, r0
     108:	a2 31       	cpi	r26, 0x12	; 18
     10a:	b1 07       	cpc	r27, r17
     10c:	d9 f7       	brne	.-10     	; 0x104 <__do_copy_data+0x10>

0000010e <__do_clear_bss>:
     10e:	22 e0       	ldi	r18, 0x02	; 2
     110:	a2 e1       	ldi	r26, 0x12	; 18
     112:	b2 e0       	ldi	r27, 0x02	; 2
     114:	01 c0       	rjmp	.+2      	; 0x118 <.do_clear_bss_start>

00000116 <.do_clear_bss_loop>:
     116:	1d 92       	st	X+, r1

00000118 <.do_clear_bss_start>:
     118:	aa 32       	cpi	r26, 0x2A	; 42
     11a:	b2 07       	cpc	r27, r18
     11c:	e1 f7       	brne	.-8      	; 0x116 <.do_clear_bss_loop>
     11e:	0e 94 34 0a 	call	0x1468	; 0x1468 <main>
     122:	0c 94 a3 0c 	jmp	0x1946	; 0x1946 <_exit>

00000126 <__bad_interrupt>:
     126:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000012a <lcd_set_4bit>:
		this function is mainly made to count the no. of dots robot passes in at run time
Example call:count_black_dots
*/
void count_black_dots()
{
	count++;
     12a:	86 e6       	ldi	r24, 0x66	; 102
     12c:	9e e0       	ldi	r25, 0x0E	; 14
     12e:	01 97       	sbiw	r24, 0x01	; 1
     130:	f1 f7       	brne	.-4      	; 0x12e <lcd_set_4bit+0x4>
     132:	00 00       	nop
     134:	40 98       	cbi	0x08, 0	; 8
     136:	41 98       	cbi	0x08, 1	; 8
     138:	80 e3       	ldi	r24, 0x30	; 48
     13a:	88 b9       	out	0x08, r24	; 8
     13c:	42 9a       	sbi	0x08, 2	; 8
     13e:	ef ef       	ldi	r30, 0xFF	; 255
     140:	f7 e4       	ldi	r31, 0x47	; 71
     142:	31 97       	sbiw	r30, 0x01	; 1
     144:	f1 f7       	brne	.-4      	; 0x142 <lcd_set_4bit+0x18>
     146:	00 c0       	rjmp	.+0      	; 0x148 <lcd_set_4bit+0x1e>
     148:	00 00       	nop
     14a:	42 98       	cbi	0x08, 2	; 8
     14c:	e6 e6       	ldi	r30, 0x66	; 102
     14e:	fe e0       	ldi	r31, 0x0E	; 14
     150:	31 97       	sbiw	r30, 0x01	; 1
     152:	f1 f7       	brne	.-4      	; 0x150 <lcd_set_4bit+0x26>
     154:	00 00       	nop
     156:	40 98       	cbi	0x08, 0	; 8
     158:	41 98       	cbi	0x08, 1	; 8
     15a:	88 b9       	out	0x08, r24	; 8
     15c:	42 9a       	sbi	0x08, 2	; 8
     15e:	ef ef       	ldi	r30, 0xFF	; 255
     160:	f7 e4       	ldi	r31, 0x47	; 71
     162:	31 97       	sbiw	r30, 0x01	; 1
     164:	f1 f7       	brne	.-4      	; 0x162 <lcd_set_4bit+0x38>
     166:	00 c0       	rjmp	.+0      	; 0x168 <lcd_set_4bit+0x3e>
     168:	00 00       	nop
     16a:	42 98       	cbi	0x08, 2	; 8
     16c:	e6 e6       	ldi	r30, 0x66	; 102
     16e:	fe e0       	ldi	r31, 0x0E	; 14
     170:	31 97       	sbiw	r30, 0x01	; 1
     172:	f1 f7       	brne	.-4      	; 0x170 <lcd_set_4bit+0x46>
     174:	00 00       	nop
     176:	40 98       	cbi	0x08, 0	; 8
     178:	41 98       	cbi	0x08, 1	; 8
     17a:	88 b9       	out	0x08, r24	; 8
     17c:	42 9a       	sbi	0x08, 2	; 8
     17e:	8f ef       	ldi	r24, 0xFF	; 255
     180:	97 e4       	ldi	r25, 0x47	; 71
     182:	01 97       	sbiw	r24, 0x01	; 1
     184:	f1 f7       	brne	.-4      	; 0x182 <lcd_set_4bit+0x58>
     186:	00 c0       	rjmp	.+0      	; 0x188 <lcd_set_4bit+0x5e>
     188:	00 00       	nop
     18a:	42 98       	cbi	0x08, 2	; 8
     18c:	e6 e6       	ldi	r30, 0x66	; 102
     18e:	fe e0       	ldi	r31, 0x0E	; 14
     190:	31 97       	sbiw	r30, 0x01	; 1
     192:	f1 f7       	brne	.-4      	; 0x190 <lcd_set_4bit+0x66>
     194:	00 00       	nop
     196:	40 98       	cbi	0x08, 0	; 8
     198:	41 98       	cbi	0x08, 1	; 8
     19a:	80 e2       	ldi	r24, 0x20	; 32
     19c:	88 b9       	out	0x08, r24	; 8
     19e:	42 9a       	sbi	0x08, 2	; 8
     1a0:	8f ef       	ldi	r24, 0xFF	; 255
     1a2:	97 e4       	ldi	r25, 0x47	; 71
     1a4:	01 97       	sbiw	r24, 0x01	; 1
     1a6:	f1 f7       	brne	.-4      	; 0x1a4 <lcd_set_4bit+0x7a>
     1a8:	00 c0       	rjmp	.+0      	; 0x1aa <lcd_set_4bit+0x80>
     1aa:	00 00       	nop
     1ac:	42 98       	cbi	0x08, 2	; 8
     1ae:	08 95       	ret

000001b0 <lcd_wr_command>:
     1b0:	98 b1       	in	r25, 0x08	; 8
     1b2:	9f 70       	andi	r25, 0x0F	; 15
     1b4:	98 b9       	out	0x08, r25	; 8
     1b6:	98 b1       	in	r25, 0x08	; 8
     1b8:	28 2f       	mov	r18, r24
     1ba:	20 7f       	andi	r18, 0xF0	; 240
     1bc:	92 2b       	or	r25, r18
     1be:	98 b9       	out	0x08, r25	; 8
     1c0:	40 98       	cbi	0x08, 0	; 8
     1c2:	41 98       	cbi	0x08, 1	; 8
     1c4:	42 9a       	sbi	0x08, 2	; 8
     1c6:	ef ef       	ldi	r30, 0xFF	; 255
     1c8:	f7 e4       	ldi	r31, 0x47	; 71
     1ca:	31 97       	sbiw	r30, 0x01	; 1
     1cc:	f1 f7       	brne	.-4      	; 0x1ca <lcd_wr_command+0x1a>
     1ce:	00 c0       	rjmp	.+0      	; 0x1d0 <lcd_wr_command+0x20>
     1d0:	00 00       	nop
     1d2:	42 98       	cbi	0x08, 2	; 8
     1d4:	98 b1       	in	r25, 0x08	; 8
     1d6:	9f 70       	andi	r25, 0x0F	; 15
     1d8:	98 b9       	out	0x08, r25	; 8
     1da:	98 b1       	in	r25, 0x08	; 8
     1dc:	82 95       	swap	r24
     1de:	80 7f       	andi	r24, 0xF0	; 240
     1e0:	89 2b       	or	r24, r25
     1e2:	88 b9       	out	0x08, r24	; 8
     1e4:	40 98       	cbi	0x08, 0	; 8
     1e6:	41 98       	cbi	0x08, 1	; 8
     1e8:	42 9a       	sbi	0x08, 2	; 8
     1ea:	8f ef       	ldi	r24, 0xFF	; 255
     1ec:	97 e4       	ldi	r25, 0x47	; 71
     1ee:	01 97       	sbiw	r24, 0x01	; 1
     1f0:	f1 f7       	brne	.-4      	; 0x1ee <lcd_wr_command+0x3e>
     1f2:	00 c0       	rjmp	.+0      	; 0x1f4 <lcd_wr_command+0x44>
     1f4:	00 00       	nop
     1f6:	42 98       	cbi	0x08, 2	; 8
     1f8:	08 95       	ret

000001fa <lcd_init>:
     1fa:	0e 94 95 00 	call	0x12a	; 0x12a <lcd_set_4bit>
     1fe:	86 e6       	ldi	r24, 0x66	; 102
     200:	9e e0       	ldi	r25, 0x0E	; 14
     202:	01 97       	sbiw	r24, 0x01	; 1
     204:	f1 f7       	brne	.-4      	; 0x202 <lcd_init+0x8>
     206:	00 00       	nop
     208:	88 e2       	ldi	r24, 0x28	; 40
     20a:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <lcd_wr_command>
     20e:	81 e0       	ldi	r24, 0x01	; 1
     210:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <lcd_wr_command>
     214:	86 e0       	ldi	r24, 0x06	; 6
     216:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <lcd_wr_command>
     21a:	8e e0       	ldi	r24, 0x0E	; 14
     21c:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <lcd_wr_command>
     220:	80 e8       	ldi	r24, 0x80	; 128
     222:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <lcd_wr_command>
     226:	08 95       	ret

00000228 <uart0_init>:
     228:	e1 ec       	ldi	r30, 0xC1	; 193
     22a:	f0 e0       	ldi	r31, 0x00	; 0
     22c:	10 82       	st	Z, r1
     22e:	10 92 c0 00 	sts	0x00C0, r1	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
     232:	86 e0       	ldi	r24, 0x06	; 6
     234:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7000c2>
     238:	8f e5       	ldi	r24, 0x5F	; 95
     23a:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7000c4>
     23e:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7000c5>
     242:	88 e9       	ldi	r24, 0x98	; 152
     244:	80 83       	st	Z, r24
     246:	08 95       	ret

00000248 <servo1_pin_config>:
     248:	25 9a       	sbi	0x04, 5	; 4
     24a:	2d 9a       	sbi	0x05, 5	; 5
     24c:	08 95       	ret

0000024e <servo2_pin_config>:
     24e:	26 9a       	sbi	0x04, 6	; 4
     250:	2e 9a       	sbi	0x05, 6	; 5
     252:	08 95       	ret

00000254 <servo3_pin_config>:
     254:	27 9a       	sbi	0x04, 7	; 4
     256:	2f 9a       	sbi	0x05, 7	; 5
     258:	08 95       	ret

0000025a <timer1_init>:
     25a:	e1 e8       	ldi	r30, 0x81	; 129
     25c:	f0 e0       	ldi	r31, 0x00	; 0
     25e:	10 82       	st	Z, r1
     260:	8c ef       	ldi	r24, 0xFC	; 252
     262:	80 93 85 00 	sts	0x0085, r24	; 0x800085 <__TEXT_REGION_LENGTH__+0x700085>
     266:	81 e0       	ldi	r24, 0x01	; 1
     268:	80 93 84 00 	sts	0x0084, r24	; 0x800084 <__TEXT_REGION_LENGTH__+0x700084>
     26c:	93 e0       	ldi	r25, 0x03	; 3
     26e:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
     272:	8f ef       	ldi	r24, 0xFF	; 255
     274:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
     278:	90 93 8b 00 	sts	0x008B, r25	; 0x80008b <__TEXT_REGION_LENGTH__+0x70008b>
     27c:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <__TEXT_REGION_LENGTH__+0x70008a>
     280:	90 93 8d 00 	sts	0x008D, r25	; 0x80008d <__TEXT_REGION_LENGTH__+0x70008d>
     284:	80 93 8c 00 	sts	0x008C, r24	; 0x80008c <__TEXT_REGION_LENGTH__+0x70008c>
     288:	90 93 87 00 	sts	0x0087, r25	; 0x800087 <__TEXT_REGION_LENGTH__+0x700087>
     28c:	80 93 86 00 	sts	0x0086, r24	; 0x800086 <__TEXT_REGION_LENGTH__+0x700086>
     290:	8b ea       	ldi	r24, 0xAB	; 171
     292:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
     296:	10 92 82 00 	sts	0x0082, r1	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
     29a:	8c e0       	ldi	r24, 0x0C	; 12
     29c:	80 83       	st	Z, r24
     29e:	08 95       	ret

000002a0 <servo_1_free>:
     2a0:	83 e0       	ldi	r24, 0x03	; 3
     2a2:	80 93 89 00 	sts	0x0089, r24	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
     2a6:	8f ef       	ldi	r24, 0xFF	; 255
     2a8:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
     2ac:	08 95       	ret

000002ae <servo_2_free>:
     2ae:	83 e0       	ldi	r24, 0x03	; 3
     2b0:	80 93 8b 00 	sts	0x008B, r24	; 0x80008b <__TEXT_REGION_LENGTH__+0x70008b>
     2b4:	8f ef       	ldi	r24, 0xFF	; 255
     2b6:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <__TEXT_REGION_LENGTH__+0x70008a>
     2ba:	08 95       	ret

000002bc <servo_3_free>:
     2bc:	83 e0       	ldi	r24, 0x03	; 3
     2be:	80 93 8d 00 	sts	0x008D, r24	; 0x80008d <__TEXT_REGION_LENGTH__+0x70008d>
     2c2:	8f ef       	ldi	r24, 0xFF	; 255
     2c4:	80 93 8c 00 	sts	0x008C, r24	; 0x80008c <__TEXT_REGION_LENGTH__+0x70008c>
     2c8:	08 95       	ret

000002ca <lcd_port_config>:
     2ca:	87 b1       	in	r24, 0x07	; 7
     2cc:	87 6f       	ori	r24, 0xF7	; 247
     2ce:	87 b9       	out	0x07, r24	; 7
     2d0:	88 b1       	in	r24, 0x08	; 8
     2d2:	80 78       	andi	r24, 0x80	; 128
     2d4:	88 b9       	out	0x08, r24	; 8
     2d6:	08 95       	ret

000002d8 <adc_pin_config>:
     2d8:	10 ba       	out	0x10, r1	; 16
     2da:	11 ba       	out	0x11, r1	; 17
     2dc:	10 92 07 01 	sts	0x0107, r1	; 0x800107 <__TEXT_REGION_LENGTH__+0x700107>
     2e0:	10 92 08 01 	sts	0x0108, r1	; 0x800108 <__TEXT_REGION_LENGTH__+0x700108>
     2e4:	08 95       	ret

000002e6 <motion_pin_config>:
     2e6:	81 b1       	in	r24, 0x01	; 1
     2e8:	8f 60       	ori	r24, 0x0F	; 15
     2ea:	81 b9       	out	0x01, r24	; 1
     2ec:	82 b1       	in	r24, 0x02	; 2
     2ee:	80 7f       	andi	r24, 0xF0	; 240
     2f0:	82 b9       	out	0x02, r24	; 2
     2f2:	ea e0       	ldi	r30, 0x0A	; 10
     2f4:	f1 e0       	ldi	r31, 0x01	; 1
     2f6:	80 81       	ld	r24, Z
     2f8:	88 61       	ori	r24, 0x18	; 24
     2fa:	80 83       	st	Z, r24
     2fc:	eb e0       	ldi	r30, 0x0B	; 11
     2fe:	f1 e0       	ldi	r31, 0x01	; 1
     300:	80 81       	ld	r24, Z
     302:	88 61       	ori	r24, 0x18	; 24
     304:	80 83       	st	Z, r24
     306:	08 95       	ret

00000308 <left_encoder_pin_config>:
     308:	6c 98       	cbi	0x0d, 4	; 13
     30a:	74 9a       	sbi	0x0e, 4	; 14
     30c:	08 95       	ret

0000030e <right_encoder_pin_config>:
     30e:	6d 98       	cbi	0x0d, 5	; 13
     310:	75 9a       	sbi	0x0e, 5	; 14
     312:	08 95       	ret

00000314 <buzzer_pin_config>:
     314:	3b 9a       	sbi	0x07, 3	; 7
     316:	43 98       	cbi	0x08, 3	; 8
     318:	08 95       	ret

0000031a <port_init>:
     31a:	0e 94 8a 01 	call	0x314	; 0x314 <buzzer_pin_config>
     31e:	0e 94 65 01 	call	0x2ca	; 0x2ca <lcd_port_config>
     322:	0e 94 6c 01 	call	0x2d8	; 0x2d8 <adc_pin_config>
     326:	0e 94 73 01 	call	0x2e6	; 0x2e6 <motion_pin_config>
     32a:	0e 94 84 01 	call	0x308	; 0x308 <left_encoder_pin_config>
     32e:	0e 94 87 01 	call	0x30e	; 0x30e <right_encoder_pin_config>
     332:	0e 94 24 01 	call	0x248	; 0x248 <servo1_pin_config>
     336:	0e 94 27 01 	call	0x24e	; 0x24e <servo2_pin_config>
     33a:	0e 94 2a 01 	call	0x254	; 0x254 <servo3_pin_config>
     33e:	08 95       	ret

00000340 <left_position_encoder_interrupt_init>:
     340:	f8 94       	cli
     342:	ea e6       	ldi	r30, 0x6A	; 106
     344:	f0 e0       	ldi	r31, 0x00	; 0
     346:	80 81       	ld	r24, Z
     348:	82 60       	ori	r24, 0x02	; 2
     34a:	80 83       	st	Z, r24
     34c:	ec 9a       	sbi	0x1d, 4	; 29
     34e:	78 94       	sei
     350:	08 95       	ret

00000352 <right_position_encoder_interrupt_init>:
     352:	f8 94       	cli
     354:	ea e6       	ldi	r30, 0x6A	; 106
     356:	f0 e0       	ldi	r31, 0x00	; 0
     358:	80 81       	ld	r24, Z
     35a:	88 60       	ori	r24, 0x08	; 8
     35c:	80 83       	st	Z, r24
     35e:	ed 9a       	sbi	0x1d, 5	; 29
     360:	78 94       	sei
     362:	08 95       	ret

00000364 <__vector_6>:
     364:	1f 92       	push	r1
     366:	0f 92       	push	r0
     368:	0f b6       	in	r0, 0x3f	; 63
     36a:	0f 92       	push	r0
     36c:	11 24       	eor	r1, r1
     36e:	8f 93       	push	r24
     370:	9f 93       	push	r25
     372:	af 93       	push	r26
     374:	bf 93       	push	r27
     376:	80 91 16 02 	lds	r24, 0x0216	; 0x800216 <ShaftCountRight>
     37a:	90 91 17 02 	lds	r25, 0x0217	; 0x800217 <ShaftCountRight+0x1>
     37e:	a0 91 18 02 	lds	r26, 0x0218	; 0x800218 <ShaftCountRight+0x2>
     382:	b0 91 19 02 	lds	r27, 0x0219	; 0x800219 <ShaftCountRight+0x3>
     386:	01 96       	adiw	r24, 0x01	; 1
     388:	a1 1d       	adc	r26, r1
     38a:	b1 1d       	adc	r27, r1
     38c:	80 93 16 02 	sts	0x0216, r24	; 0x800216 <ShaftCountRight>
     390:	90 93 17 02 	sts	0x0217, r25	; 0x800217 <ShaftCountRight+0x1>
     394:	a0 93 18 02 	sts	0x0218, r26	; 0x800218 <ShaftCountRight+0x2>
     398:	b0 93 19 02 	sts	0x0219, r27	; 0x800219 <ShaftCountRight+0x3>
     39c:	bf 91       	pop	r27
     39e:	af 91       	pop	r26
     3a0:	9f 91       	pop	r25
     3a2:	8f 91       	pop	r24
     3a4:	0f 90       	pop	r0
     3a6:	0f be       	out	0x3f, r0	; 63
     3a8:	0f 90       	pop	r0
     3aa:	1f 90       	pop	r1
     3ac:	18 95       	reti

000003ae <__vector_5>:
     3ae:	1f 92       	push	r1
     3b0:	0f 92       	push	r0
     3b2:	0f b6       	in	r0, 0x3f	; 63
     3b4:	0f 92       	push	r0
     3b6:	11 24       	eor	r1, r1
     3b8:	8f 93       	push	r24
     3ba:	9f 93       	push	r25
     3bc:	af 93       	push	r26
     3be:	bf 93       	push	r27
     3c0:	80 91 1a 02 	lds	r24, 0x021A	; 0x80021a <ShaftCountLeft>
     3c4:	90 91 1b 02 	lds	r25, 0x021B	; 0x80021b <ShaftCountLeft+0x1>
     3c8:	a0 91 1c 02 	lds	r26, 0x021C	; 0x80021c <ShaftCountLeft+0x2>
     3cc:	b0 91 1d 02 	lds	r27, 0x021D	; 0x80021d <ShaftCountLeft+0x3>
     3d0:	01 96       	adiw	r24, 0x01	; 1
     3d2:	a1 1d       	adc	r26, r1
     3d4:	b1 1d       	adc	r27, r1
     3d6:	80 93 1a 02 	sts	0x021A, r24	; 0x80021a <ShaftCountLeft>
     3da:	90 93 1b 02 	sts	0x021B, r25	; 0x80021b <ShaftCountLeft+0x1>
     3de:	a0 93 1c 02 	sts	0x021C, r26	; 0x80021c <ShaftCountLeft+0x2>
     3e2:	b0 93 1d 02 	sts	0x021D, r27	; 0x80021d <ShaftCountLeft+0x3>
     3e6:	bf 91       	pop	r27
     3e8:	af 91       	pop	r26
     3ea:	9f 91       	pop	r25
     3ec:	8f 91       	pop	r24
     3ee:	0f 90       	pop	r0
     3f0:	0f be       	out	0x3f, r0	; 63
     3f2:	0f 90       	pop	r0
     3f4:	1f 90       	pop	r1
     3f6:	18 95       	reti

000003f8 <timer5_init>:
     3f8:	e1 e2       	ldi	r30, 0x21	; 33
     3fa:	f1 e0       	ldi	r31, 0x01	; 1
     3fc:	10 82       	st	Z, r1
     3fe:	8f ef       	ldi	r24, 0xFF	; 255
     400:	80 93 25 01 	sts	0x0125, r24	; 0x800125 <__TEXT_REGION_LENGTH__+0x700125>
     404:	91 e0       	ldi	r25, 0x01	; 1
     406:	90 93 24 01 	sts	0x0124, r25	; 0x800124 <__TEXT_REGION_LENGTH__+0x700124>
     40a:	10 92 29 01 	sts	0x0129, r1	; 0x800129 <__TEXT_REGION_LENGTH__+0x700129>
     40e:	80 93 28 01 	sts	0x0128, r24	; 0x800128 <__TEXT_REGION_LENGTH__+0x700128>
     412:	10 92 2b 01 	sts	0x012B, r1	; 0x80012b <__TEXT_REGION_LENGTH__+0x70012b>
     416:	80 93 2a 01 	sts	0x012A, r24	; 0x80012a <__TEXT_REGION_LENGTH__+0x70012a>
     41a:	10 92 2d 01 	sts	0x012D, r1	; 0x80012d <__TEXT_REGION_LENGTH__+0x70012d>
     41e:	80 93 2c 01 	sts	0x012C, r24	; 0x80012c <__TEXT_REGION_LENGTH__+0x70012c>
     422:	89 ea       	ldi	r24, 0xA9	; 169
     424:	80 93 20 01 	sts	0x0120, r24	; 0x800120 <__TEXT_REGION_LENGTH__+0x700120>
     428:	8b e0       	ldi	r24, 0x0B	; 11
     42a:	80 83       	st	Z, r24
     42c:	08 95       	ret

0000042e <adc_init>:
     42e:	ea e7       	ldi	r30, 0x7A	; 122
     430:	f0 e0       	ldi	r31, 0x00	; 0
     432:	10 82       	st	Z, r1
     434:	10 92 7b 00 	sts	0x007B, r1	; 0x80007b <__TEXT_REGION_LENGTH__+0x70007b>
     438:	80 e2       	ldi	r24, 0x20	; 32
     43a:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__TEXT_REGION_LENGTH__+0x70007c>
     43e:	80 e8       	ldi	r24, 0x80	; 128
     440:	80 bf       	out	0x30, r24	; 48
     442:	86 e8       	ldi	r24, 0x86	; 134
     444:	80 83       	st	Z, r24
     446:	08 95       	ret

00000448 <ADC_Conversion>:
     448:	88 30       	cpi	r24, 0x08	; 8
     44a:	18 f0       	brcs	.+6      	; 0x452 <ADC_Conversion+0xa>
     44c:	98 e0       	ldi	r25, 0x08	; 8
     44e:	90 93 7b 00 	sts	0x007B, r25	; 0x80007b <__TEXT_REGION_LENGTH__+0x70007b>
     452:	87 70       	andi	r24, 0x07	; 7
     454:	80 62       	ori	r24, 0x20	; 32
     456:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__TEXT_REGION_LENGTH__+0x70007c>
     45a:	ea e7       	ldi	r30, 0x7A	; 122
     45c:	f0 e0       	ldi	r31, 0x00	; 0
     45e:	80 81       	ld	r24, Z
     460:	80 64       	ori	r24, 0x40	; 64
     462:	80 83       	st	Z, r24
     464:	80 81       	ld	r24, Z
     466:	84 ff       	sbrs	r24, 4
     468:	fd cf       	rjmp	.-6      	; 0x464 <ADC_Conversion+0x1c>
     46a:	80 91 79 00 	lds	r24, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x700079>
     46e:	ea e7       	ldi	r30, 0x7A	; 122
     470:	f0 e0       	ldi	r31, 0x00	; 0
     472:	90 81       	ld	r25, Z
     474:	90 61       	ori	r25, 0x10	; 16
     476:	90 83       	st	Z, r25
     478:	10 92 7b 00 	sts	0x007B, r1	; 0x80007b <__TEXT_REGION_LENGTH__+0x70007b>
     47c:	08 95       	ret

0000047e <motion_set>:
     47e:	92 b1       	in	r25, 0x02	; 2
     480:	90 7f       	andi	r25, 0xF0	; 240
     482:	8f 70       	andi	r24, 0x0F	; 15
     484:	98 2b       	or	r25, r24
     486:	92 b9       	out	0x02, r25	; 2
     488:	08 95       	ret

0000048a <buzzer_on>:
     48a:	86 b1       	in	r24, 0x06	; 6
     48c:	88 60       	ori	r24, 0x08	; 8
     48e:	88 b9       	out	0x08, r24	; 8
     490:	08 95       	ret

00000492 <buzzer_off>:
     492:	86 b1       	in	r24, 0x06	; 6
     494:	87 7f       	andi	r24, 0xF7	; 247
     496:	88 b9       	out	0x08, r24	; 8
     498:	08 95       	ret

0000049a <forward>:
     49a:	86 e0       	ldi	r24, 0x06	; 6
     49c:	0e 94 3f 02 	call	0x47e	; 0x47e <motion_set>
     4a0:	08 95       	ret

000004a2 <back>:
     4a2:	89 e0       	ldi	r24, 0x09	; 9
     4a4:	0e 94 3f 02 	call	0x47e	; 0x47e <motion_set>
     4a8:	08 95       	ret

000004aa <left>:
     4aa:	85 e0       	ldi	r24, 0x05	; 5
     4ac:	0e 94 3f 02 	call	0x47e	; 0x47e <motion_set>
     4b0:	08 95       	ret

000004b2 <right>:
     4b2:	8a e0       	ldi	r24, 0x0A	; 10
     4b4:	0e 94 3f 02 	call	0x47e	; 0x47e <motion_set>
     4b8:	08 95       	ret

000004ba <stop>:
     4ba:	80 e0       	ldi	r24, 0x00	; 0
     4bc:	0e 94 3f 02 	call	0x47e	; 0x47e <motion_set>
     4c0:	08 95       	ret

000004c2 <linear_distance_mm>:
     4c2:	bc 01       	movw	r22, r24
     4c4:	80 e0       	ldi	r24, 0x00	; 0
     4c6:	90 e0       	ldi	r25, 0x00	; 0
     4c8:	0e 94 15 0c 	call	0x182a	; 0x182a <__floatunsisf>
     4cc:	25 ee       	ldi	r18, 0xE5	; 229
     4ce:	30 ed       	ldi	r19, 0xD0	; 208
     4d0:	4a ea       	ldi	r20, 0xAA	; 170
     4d2:	50 e4       	ldi	r21, 0x40	; 64
     4d4:	0e 94 74 0b 	call	0x16e8	; 0x16e8 <__divsf3>
     4d8:	0e 94 e6 0b 	call	0x17cc	; 0x17cc <__fixunssfsi>
     4dc:	ab 01       	movw	r20, r22
     4de:	bc 01       	movw	r22, r24
     4e0:	10 92 16 02 	sts	0x0216, r1	; 0x800216 <ShaftCountRight>
     4e4:	10 92 17 02 	sts	0x0217, r1	; 0x800217 <ShaftCountRight+0x1>
     4e8:	10 92 18 02 	sts	0x0218, r1	; 0x800218 <ShaftCountRight+0x2>
     4ec:	10 92 19 02 	sts	0x0219, r1	; 0x800219 <ShaftCountRight+0x3>
     4f0:	80 91 16 02 	lds	r24, 0x0216	; 0x800216 <ShaftCountRight>
     4f4:	90 91 17 02 	lds	r25, 0x0217	; 0x800217 <ShaftCountRight+0x1>
     4f8:	a0 91 18 02 	lds	r26, 0x0218	; 0x800218 <ShaftCountRight+0x2>
     4fc:	b0 91 19 02 	lds	r27, 0x0219	; 0x800219 <ShaftCountRight+0x3>
     500:	48 17       	cp	r20, r24
     502:	59 07       	cpc	r21, r25
     504:	6a 07       	cpc	r22, r26
     506:	7b 07       	cpc	r23, r27
     508:	98 f7       	brcc	.-26     	; 0x4f0 <linear_distance_mm+0x2e>
     50a:	0e 94 5d 02 	call	0x4ba	; 0x4ba <stop>
     50e:	08 95       	ret

00000510 <forward_mm>:
     510:	cf 93       	push	r28
     512:	df 93       	push	r29
     514:	ec 01       	movw	r28, r24
     516:	0e 94 4d 02 	call	0x49a	; 0x49a <forward>
     51a:	8c ed       	ldi	r24, 0xDC	; 220
     51c:	80 93 28 01 	sts	0x0128, r24	; 0x800128 <__TEXT_REGION_LENGTH__+0x700128>
     520:	80 93 2a 01 	sts	0x012A, r24	; 0x80012a <__TEXT_REGION_LENGTH__+0x70012a>
     524:	ce 01       	movw	r24, r28
     526:	0e 94 61 02 	call	0x4c2	; 0x4c2 <linear_distance_mm>
     52a:	df 91       	pop	r29
     52c:	cf 91       	pop	r28
     52e:	08 95       	ret

00000530 <init_devices>:
     530:	f8 94       	cli
     532:	0e 94 8d 01 	call	0x31a	; 0x31a <port_init>
     536:	0e 94 14 01 	call	0x228	; 0x228 <uart0_init>
     53a:	0e 94 17 02 	call	0x42e	; 0x42e <adc_init>
     53e:	0e 94 fc 01 	call	0x3f8	; 0x3f8 <timer5_init>
     542:	0e 94 2d 01 	call	0x25a	; 0x25a <timer1_init>
     546:	0e 94 a0 01 	call	0x340	; 0x340 <left_position_encoder_interrupt_init>
     54a:	0e 94 a9 01 	call	0x352	; 0x352 <right_position_encoder_interrupt_init>
     54e:	78 94       	sei
     550:	08 95       	ret

00000552 <initialize_servo>:
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     552:	2f ef       	ldi	r18, 0xFF	; 255
     554:	8f e7       	ldi	r24, 0x7F	; 127
     556:	93 e4       	ldi	r25, 0x43	; 67
     558:	21 50       	subi	r18, 0x01	; 1
     55a:	80 40       	sbci	r24, 0x00	; 0
     55c:	90 40       	sbci	r25, 0x00	; 0
     55e:	e1 f7       	brne	.-8      	; 0x558 <initialize_servo+0x6>
     560:	00 c0       	rjmp	.+0      	; 0x562 <initialize_servo+0x10>
     562:	00 00       	nop
//Function to rotate Servo 2 by a specified angle in the multiples of 1.86 degrees
void servo_2(unsigned char degrees)
{
	float PositionTiltServo = 0;
	PositionTiltServo = ((float)degrees / 1.86) + 35.0;
	OCR1BH = 0x00;
     564:	10 92 8b 00 	sts	0x008B, r1	; 0x80008b <__TEXT_REGION_LENGTH__+0x70008b>
	OCR1BL = (unsigned char) PositionTiltServo;
     568:	88 e5       	ldi	r24, 0x58	; 88
     56a:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <__TEXT_REGION_LENGTH__+0x70008a>
     56e:	2f ef       	ldi	r18, 0xFF	; 255
     570:	8f e7       	ldi	r24, 0x7F	; 127
     572:	93 e4       	ldi	r25, 0x43	; 67
     574:	21 50       	subi	r18, 0x01	; 1
     576:	80 40       	sbci	r24, 0x00	; 0
     578:	90 40       	sbci	r25, 0x00	; 0
     57a:	e1 f7       	brne	.-8      	; 0x574 <initialize_servo+0x22>
     57c:	00 c0       	rjmp	.+0      	; 0x57e <initialize_servo+0x2c>
     57e:	00 00       	nop
//Function to rotate Servo 1 by a specified angle in the multiples of 1.86 degrees
void servo_1(unsigned char degrees)
{
	float PositionPanServo = 0;
	PositionPanServo = ((float)degrees / 1.86) + 35.0;
	OCR1AH = 0x00;
     580:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
	OCR1AL = (unsigned char) PositionPanServo;
     584:	83 e8       	ldi	r24, 0x83	; 131
     586:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
     58a:	2f ef       	ldi	r18, 0xFF	; 255
     58c:	8f e7       	ldi	r24, 0x7F	; 127
     58e:	93 e4       	ldi	r25, 0x43	; 67
     590:	21 50       	subi	r18, 0x01	; 1
     592:	80 40       	sbci	r24, 0x00	; 0
     594:	90 40       	sbci	r25, 0x00	; 0
     596:	e1 f7       	brne	.-8      	; 0x590 <initialize_servo+0x3e>
     598:	00 c0       	rjmp	.+0      	; 0x59a <initialize_servo+0x48>
     59a:	00 00       	nop
//Function to rotate Servo 3 by a specified angle in the multiples of 1.86 degrees
void servo_3(unsigned char degrees)
{
	float PositionServo = 0;
	PositionServo = ((float)degrees / 1.86) + 35.0;
	OCR1CH = 0x00;
     59c:	10 92 8d 00 	sts	0x008D, r1	; 0x80008d <__TEXT_REGION_LENGTH__+0x70008d>
	OCR1CL = (unsigned char) PositionServo;
     5a0:	83 e2       	ldi	r24, 0x23	; 35
     5a2:	80 93 8c 00 	sts	0x008C, r24	; 0x80008c <__TEXT_REGION_LENGTH__+0x70008c>
     5a6:	2f ef       	ldi	r18, 0xFF	; 255
     5a8:	8f e7       	ldi	r24, 0x7F	; 127
     5aa:	93 e4       	ldi	r25, 0x43	; 67
     5ac:	21 50       	subi	r18, 0x01	; 1
     5ae:	80 40       	sbci	r24, 0x00	; 0
     5b0:	90 40       	sbci	r25, 0x00	; 0
     5b2:	e1 f7       	brne	.-8      	; 0x5ac <initialize_servo+0x5a>
     5b4:	00 c0       	rjmp	.+0      	; 0x5b6 <initialize_servo+0x64>
     5b6:	00 00       	nop
	_delay_ms(1500);
	servo_1(180);
	_delay_ms(1500);
	servo_3(0);
	_delay_ms(1500);
	servo_1_free();
     5b8:	0e 94 50 01 	call	0x2a0	; 0x2a0 <servo_1_free>
	servo_2_free();
     5bc:	0e 94 57 01 	call	0x2ae	; 0x2ae <servo_2_free>
	servo_3_free();
     5c0:	0e 94 5e 01 	call	0x2bc	; 0x2bc <servo_3_free>
     5c4:	08 95       	ret

000005c6 <pickup_and_place>:
Output:no output
logic:this function will pick the block up and place it in the (empty_container)th container
Example call:pickup_and_place(2)
*/
void pickup_and_place(int empty_container)//pickups the block and places them in the container
{
     5c6:	ef 92       	push	r14
     5c8:	ff 92       	push	r15
     5ca:	0f 93       	push	r16
     5cc:	1f 93       	push	r17
     5ce:	cf 93       	push	r28
     5d0:	df 93       	push	r29
     5d2:	ec 01       	movw	r28, r24
	char signal_to_blender='A';//taken an initial value of signal
	signal_to_blender+=object_sequence[i]-1;//incremented the value by the no. at which object is placed - 1 i.e. now for position 1 signal is A, for 2 signal is B and so on
     5d4:	e0 91 20 02 	lds	r30, 0x0220	; 0x800220 <i>
     5d8:	f0 91 21 02 	lds	r31, 0x0221	; 0x800221 <i+0x1>
     5dc:	ee 0f       	add	r30, r30
     5de:	ff 1f       	adc	r31, r31
     5e0:	ea 5f       	subi	r30, 0xFA	; 250
     5e2:	fd 4f       	sbci	r31, 0xFD	; 253
     5e4:	80 81       	ld	r24, Z
     5e6:	80 5c       	subi	r24, 0xC0	; 192
logic:sends the signal multiple times since it may be possible zigbee on the other hand might not recieve the signal send from here
Example call:send('A')
*/
void send(unsigned char data_to_be_sent)//function to send data
{
		UDR0=data_to_be_sent;
     5e8:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
     5ec:	2f ef       	ldi	r18, 0xFF	; 255
     5ee:	8f eb       	ldi	r24, 0xBF	; 191
     5f0:	96 e0       	ldi	r25, 0x06	; 6
     5f2:	21 50       	subi	r18, 0x01	; 1
     5f4:	80 40       	sbci	r24, 0x00	; 0
     5f6:	90 40       	sbci	r25, 0x00	; 0
     5f8:	e1 f7       	brne	.-8      	; 0x5f2 <pickup_and_place+0x2c>
     5fa:	00 c0       	rjmp	.+0      	; 0x5fc <pickup_and_place+0x36>
     5fc:	00 00       	nop
//Function to rotate Servo 1 by a specified angle in the multiples of 1.86 degrees
void servo_1(unsigned char degrees)
{
	float PositionPanServo = 0;
	PositionPanServo = ((float)degrees / 1.86) + 35.0;
	OCR1AH = 0x00;
     5fe:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
	OCR1AL = (unsigned char) PositionPanServo;
     602:	83 e8       	ldi	r24, 0x83	; 131
     604:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
     608:	ef ef       	ldi	r30, 0xFF	; 255
     60a:	ff e7       	ldi	r31, 0x7F	; 127
     60c:	23 e4       	ldi	r18, 0x43	; 67
     60e:	e1 50       	subi	r30, 0x01	; 1
     610:	f0 40       	sbci	r31, 0x00	; 0
     612:	20 40       	sbci	r18, 0x00	; 0
     614:	e1 f7       	brne	.-8      	; 0x60e <pickup_and_place+0x48>
     616:	00 c0       	rjmp	.+0      	; 0x618 <pickup_and_place+0x52>
     618:	00 00       	nop
	//picking up the object
	
	_delay_ms(150);
	servo_1(180);//double checking the initial position
	_delay_ms(1500);
	servo_1_free();
     61a:	0e 94 50 01 	call	0x2a0	; 0x2a0 <servo_1_free>
//Function to rotate Servo 2 by a specified angle in the multiples of 1.86 degrees
void servo_2(unsigned char degrees)
{
	float PositionTiltServo = 0;
	PositionTiltServo = ((float)degrees / 1.86) + 35.0;
	OCR1BH = 0x00;
     61e:	0f 2e       	mov	r0, r31
     620:	fb e8       	ldi	r31, 0x8B	; 139
     622:	ef 2e       	mov	r14, r31
     624:	f1 2c       	mov	r15, r1
     626:	f0 2d       	mov	r31, r0
     628:	f7 01       	movw	r30, r14
     62a:	10 82       	st	Z, r1
	OCR1BL = (unsigned char) PositionTiltServo;
     62c:	0a e8       	ldi	r16, 0x8A	; 138
     62e:	10 e0       	ldi	r17, 0x00	; 0
     630:	86 e2       	ldi	r24, 0x26	; 38
     632:	f8 01       	movw	r30, r16
     634:	80 83       	st	Z, r24
     636:	ff ef       	ldi	r31, 0xFF	; 255
     638:	2f e7       	ldi	r18, 0x7F	; 127
     63a:	83 e4       	ldi	r24, 0x43	; 67
     63c:	f1 50       	subi	r31, 0x01	; 1
     63e:	20 40       	sbci	r18, 0x00	; 0
     640:	80 40       	sbci	r24, 0x00	; 0
     642:	e1 f7       	brne	.-8      	; 0x63c <pickup_and_place+0x76>
     644:	00 c0       	rjmp	.+0      	; 0x646 <pickup_and_place+0x80>
     646:	00 00       	nop
	servo_1(180);//double checking the initial position
	_delay_ms(1500);
	servo_1_free();
	servo_2(7);//arm comes down
	_delay_ms(1500);
	servo_2_free();
     648:	0e 94 57 01 	call	0x2ae	; 0x2ae <servo_2_free>
//Function to rotate Servo 3 by a specified angle in the multiples of 1.86 degrees
void servo_3(unsigned char degrees)
{
	float PositionServo = 0;
	PositionServo = ((float)degrees / 1.86) + 35.0;
	OCR1CH = 0x00;
     64c:	10 92 8d 00 	sts	0x008D, r1	; 0x80008d <__TEXT_REGION_LENGTH__+0x70008d>
	OCR1CL = (unsigned char) PositionServo;
     650:	8c e4       	ldi	r24, 0x4C	; 76
     652:	80 93 8c 00 	sts	0x008C, r24	; 0x80008c <__TEXT_REGION_LENGTH__+0x70008c>
     656:	9f ef       	ldi	r25, 0xFF	; 255
     658:	ef e7       	ldi	r30, 0x7F	; 127
     65a:	f3 e4       	ldi	r31, 0x43	; 67
     65c:	91 50       	subi	r25, 0x01	; 1
     65e:	e0 40       	sbci	r30, 0x00	; 0
     660:	f0 40       	sbci	r31, 0x00	; 0
     662:	e1 f7       	brne	.-8      	; 0x65c <pickup_and_place+0x96>
     664:	00 c0       	rjmp	.+0      	; 0x666 <pickup_and_place+0xa0>
     666:	00 00       	nop
	servo_2(7);//arm comes down
	_delay_ms(1500);
	servo_2_free();
	servo_3(77);//arm grabs the object
	_delay_ms(1500);
	servo_3_free();
     668:	0e 94 5e 01 	call	0x2bc	; 0x2bc <servo_3_free>
//Function to rotate Servo 2 by a specified angle in the multiples of 1.86 degrees
void servo_2(unsigned char degrees)
{
	float PositionTiltServo = 0;
	PositionTiltServo = ((float)degrees / 1.86) + 35.0;
	OCR1BH = 0x00;
     66c:	f7 01       	movw	r30, r14
     66e:	10 82       	st	Z, r1
	OCR1BL = (unsigned char) PositionTiltServo;
     670:	88 e5       	ldi	r24, 0x58	; 88
     672:	f8 01       	movw	r30, r16
     674:	80 83       	st	Z, r24
     676:	ff ef       	ldi	r31, 0xFF	; 255
     678:	2f e7       	ldi	r18, 0x7F	; 127
     67a:	83 e4       	ldi	r24, 0x43	; 67
     67c:	f1 50       	subi	r31, 0x01	; 1
     67e:	20 40       	sbci	r18, 0x00	; 0
     680:	80 40       	sbci	r24, 0x00	; 0
     682:	e1 f7       	brne	.-8      	; 0x67c <pickup_and_place+0xb6>
     684:	00 c0       	rjmp	.+0      	; 0x686 <pickup_and_place+0xc0>
     686:	00 00       	nop
	servo_3(77);//arm grabs the object
	_delay_ms(1500);
	servo_3_free();
	servo_2(100);//arm again goes up
	_delay_ms(1500);
	servo_2_free();
     688:	0e 94 57 01 	call	0x2ae	; 0x2ae <servo_2_free>
	//one switch condition for every container
	switch(empty_container)
     68c:	c2 30       	cpi	r28, 0x02	; 2
     68e:	d1 05       	cpc	r29, r1
     690:	09 f4       	brne	.+2      	; 0x694 <pickup_and_place+0xce>
     692:	71 c0       	rjmp	.+226    	; 0x776 <pickup_and_place+0x1b0>
     694:	24 f4       	brge	.+8      	; 0x69e <pickup_and_place+0xd8>
     696:	21 97       	sbiw	r28, 0x01	; 1
     698:	09 f4       	brne	.+2      	; 0x69c <pickup_and_place+0xd6>
     69a:	a0 c0       	rjmp	.+320    	; 0x7dc <pickup_and_place+0x216>
     69c:	d0 c0       	rjmp	.+416    	; 0x83e <pickup_and_place+0x278>
     69e:	c3 30       	cpi	r28, 0x03	; 3
     6a0:	d1 05       	cpc	r29, r1
     6a2:	b1 f1       	breq	.+108    	; 0x710 <pickup_and_place+0x14a>
     6a4:	24 97       	sbiw	r28, 0x04	; 4
     6a6:	09 f0       	breq	.+2      	; 0x6aa <pickup_and_place+0xe4>
     6a8:	ca c0       	rjmp	.+404    	; 0x83e <pickup_and_place+0x278>
//Function to rotate Servo 1 by a specified angle in the multiples of 1.86 degrees
void servo_1(unsigned char degrees)
{
	float PositionPanServo = 0;
	PositionPanServo = ((float)degrees / 1.86) + 35.0;
	OCR1AH = 0x00;
     6aa:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
	OCR1AL = (unsigned char) PositionPanServo;
     6ae:	81 e5       	ldi	r24, 0x51	; 81
     6b0:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
     6b4:	9f ef       	ldi	r25, 0xFF	; 255
     6b6:	ef e7       	ldi	r30, 0x7F	; 127
     6b8:	f3 e4       	ldi	r31, 0x43	; 67
     6ba:	91 50       	subi	r25, 0x01	; 1
     6bc:	e0 40       	sbci	r30, 0x00	; 0
     6be:	f0 40       	sbci	r31, 0x00	; 0
     6c0:	e1 f7       	brne	.-8      	; 0x6ba <pickup_and_place+0xf4>
     6c2:	00 c0       	rjmp	.+0      	; 0x6c4 <pickup_and_place+0xfe>
     6c4:	00 00       	nop
	//one switch condition for every container
	switch(empty_container)
	{
		case 4: servo_1(86);//arm rotates to the specified angle
				_delay_ms(1500);
				servo_1_free();
     6c6:	0e 94 50 01 	call	0x2a0	; 0x2a0 <servo_1_free>
//Function to rotate Servo 2 by a specified angle in the multiples of 1.86 degrees
void servo_2(unsigned char degrees)
{
	float PositionTiltServo = 0;
	PositionTiltServo = ((float)degrees / 1.86) + 35.0;
	OCR1BH = 0x00;
     6ca:	10 92 8b 00 	sts	0x008B, r1	; 0x80008b <__TEXT_REGION_LENGTH__+0x70008b>
	OCR1BL = (unsigned char) PositionTiltServo;
     6ce:	83 e4       	ldi	r24, 0x43	; 67
     6d0:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <__TEXT_REGION_LENGTH__+0x70008a>
     6d4:	2f ef       	ldi	r18, 0xFF	; 255
     6d6:	8f e7       	ldi	r24, 0x7F	; 127
     6d8:	93 e4       	ldi	r25, 0x43	; 67
     6da:	21 50       	subi	r18, 0x01	; 1
     6dc:	80 40       	sbci	r24, 0x00	; 0
     6de:	90 40       	sbci	r25, 0x00	; 0
     6e0:	e1 f7       	brne	.-8      	; 0x6da <pickup_and_place+0x114>
     6e2:	00 c0       	rjmp	.+0      	; 0x6e4 <pickup_and_place+0x11e>
     6e4:	00 00       	nop
		case 4: servo_1(86);//arm rotates to the specified angle
				_delay_ms(1500);
				servo_1_free();
				servo_2(60);//arm comes down to drop the object in container
				_delay_ms(1500);
				servo_2_free();
     6e6:	0e 94 57 01 	call	0x2ae	; 0x2ae <servo_2_free>
//Function to rotate Servo 3 by a specified angle in the multiples of 1.86 degrees
void servo_3(unsigned char degrees)
{
	float PositionServo = 0;
	PositionServo = ((float)degrees / 1.86) + 35.0;
	OCR1CH = 0x00;
     6ea:	10 92 8d 00 	sts	0x008D, r1	; 0x80008d <__TEXT_REGION_LENGTH__+0x70008d>
	OCR1CL = (unsigned char) PositionServo;
     6ee:	83 e2       	ldi	r24, 0x23	; 35
     6f0:	80 93 8c 00 	sts	0x008C, r24	; 0x80008c <__TEXT_REGION_LENGTH__+0x70008c>
     6f4:	ef ef       	ldi	r30, 0xFF	; 255
     6f6:	ff e7       	ldi	r31, 0x7F	; 127
     6f8:	23 e4       	ldi	r18, 0x43	; 67
     6fa:	e1 50       	subi	r30, 0x01	; 1
     6fc:	f0 40       	sbci	r31, 0x00	; 0
     6fe:	20 40       	sbci	r18, 0x00	; 0
     700:	e1 f7       	brne	.-8      	; 0x6fa <pickup_and_place+0x134>
     702:	00 c0       	rjmp	.+0      	; 0x704 <pickup_and_place+0x13e>
     704:	00 00       	nop
				servo_2(60);//arm comes down to drop the object in container
				_delay_ms(1500);
				servo_2_free();
				servo_3(0);//flap opens and object is dropped
				_delay_ms(1500);
				servo_3_free();
     706:	0e 94 5e 01 	call	0x2bc	; 0x2bc <servo_3_free>
				initialize_servo();
     70a:	0e 94 a9 02 	call	0x552	; 0x552 <initialize_servo>
				
				break;
     70e:	97 c0       	rjmp	.+302    	; 0x83e <pickup_and_place+0x278>
//Function to rotate Servo 1 by a specified angle in the multiples of 1.86 degrees
void servo_1(unsigned char degrees)
{
	float PositionPanServo = 0;
	PositionPanServo = ((float)degrees / 1.86) + 35.0;
	OCR1AH = 0x00;
     710:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
	OCR1AL = (unsigned char) PositionPanServo;
     714:	80 e4       	ldi	r24, 0x40	; 64
     716:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
     71a:	8f ef       	ldi	r24, 0xFF	; 255
     71c:	9f e7       	ldi	r25, 0x7F	; 127
     71e:	e3 e4       	ldi	r30, 0x43	; 67
     720:	81 50       	subi	r24, 0x01	; 1
     722:	90 40       	sbci	r25, 0x00	; 0
     724:	e0 40       	sbci	r30, 0x00	; 0
     726:	e1 f7       	brne	.-8      	; 0x720 <pickup_and_place+0x15a>
     728:	00 c0       	rjmp	.+0      	; 0x72a <pickup_and_place+0x164>
     72a:	00 00       	nop
				initialize_servo();
				
				break;
		case 3: servo_1(55);//arm rotates to the specified angle
			_delay_ms(1500);
			servo_1_free();
     72c:	0e 94 50 01 	call	0x2a0	; 0x2a0 <servo_1_free>
//Function to rotate Servo 2 by a specified angle in the multiples of 1.86 degrees
void servo_2(unsigned char degrees)
{
	float PositionTiltServo = 0;
	PositionTiltServo = ((float)degrees / 1.86) + 35.0;
	OCR1BH = 0x00;
     730:	10 92 8b 00 	sts	0x008B, r1	; 0x80008b <__TEXT_REGION_LENGTH__+0x70008b>
	OCR1BL = (unsigned char) PositionTiltServo;
     734:	81 e4       	ldi	r24, 0x41	; 65
     736:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <__TEXT_REGION_LENGTH__+0x70008a>
     73a:	ff ef       	ldi	r31, 0xFF	; 255
     73c:	2f e7       	ldi	r18, 0x7F	; 127
     73e:	83 e4       	ldi	r24, 0x43	; 67
     740:	f1 50       	subi	r31, 0x01	; 1
     742:	20 40       	sbci	r18, 0x00	; 0
     744:	80 40       	sbci	r24, 0x00	; 0
     746:	e1 f7       	brne	.-8      	; 0x740 <pickup_and_place+0x17a>
     748:	00 c0       	rjmp	.+0      	; 0x74a <pickup_and_place+0x184>
     74a:	00 00       	nop
		case 3: servo_1(55);//arm rotates to the specified angle
			_delay_ms(1500);
			servo_1_free();
			servo_2(57);//arm comes down to drop the object in container
			_delay_ms(1500);
			servo_2_free();
     74c:	0e 94 57 01 	call	0x2ae	; 0x2ae <servo_2_free>
//Function to rotate Servo 3 by a specified angle in the multiples of 1.86 degrees
void servo_3(unsigned char degrees)
{
	float PositionServo = 0;
	PositionServo = ((float)degrees / 1.86) + 35.0;
	OCR1CH = 0x00;
     750:	10 92 8d 00 	sts	0x008D, r1	; 0x80008d <__TEXT_REGION_LENGTH__+0x70008d>
	OCR1CL = (unsigned char) PositionServo;
     754:	83 e2       	ldi	r24, 0x23	; 35
     756:	80 93 8c 00 	sts	0x008C, r24	; 0x80008c <__TEXT_REGION_LENGTH__+0x70008c>
     75a:	9f ef       	ldi	r25, 0xFF	; 255
     75c:	ef e7       	ldi	r30, 0x7F	; 127
     75e:	f3 e4       	ldi	r31, 0x43	; 67
     760:	91 50       	subi	r25, 0x01	; 1
     762:	e0 40       	sbci	r30, 0x00	; 0
     764:	f0 40       	sbci	r31, 0x00	; 0
     766:	e1 f7       	brne	.-8      	; 0x760 <pickup_and_place+0x19a>
     768:	00 c0       	rjmp	.+0      	; 0x76a <pickup_and_place+0x1a4>
     76a:	00 00       	nop
			servo_2(57);//arm comes down to drop the object in container
			_delay_ms(1500);
			servo_2_free();
			servo_3(0);//flap opens and object is dropped
			_delay_ms(1500);
			servo_3_free();
     76c:	0e 94 5e 01 	call	0x2bc	; 0x2bc <servo_3_free>
			initialize_servo();
     770:	0e 94 a9 02 	call	0x552	; 0x552 <initialize_servo>
			break;
     774:	64 c0       	rjmp	.+200    	; 0x83e <pickup_and_place+0x278>
//Function to rotate Servo 1 by a specified angle in the multiples of 1.86 degrees
void servo_1(unsigned char degrees)
{
	float PositionPanServo = 0;
	PositionPanServo = ((float)degrees / 1.86) + 35.0;
	OCR1AH = 0x00;
     776:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
	OCR1AL = (unsigned char) PositionPanServo;
     77a:	8f e2       	ldi	r24, 0x2F	; 47
     77c:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
     780:	2f ef       	ldi	r18, 0xFF	; 255
     782:	8f e7       	ldi	r24, 0x7F	; 127
     784:	93 e4       	ldi	r25, 0x43	; 67
     786:	21 50       	subi	r18, 0x01	; 1
     788:	80 40       	sbci	r24, 0x00	; 0
     78a:	90 40       	sbci	r25, 0x00	; 0
     78c:	e1 f7       	brne	.-8      	; 0x786 <pickup_and_place+0x1c0>
     78e:	00 c0       	rjmp	.+0      	; 0x790 <pickup_and_place+0x1ca>
     790:	00 00       	nop
			servo_3_free();
			initialize_servo();
			break;
		case 2: servo_1(23);//arm rotates to the specified angle
			_delay_ms(1500);
			servo_1_free();
     792:	0e 94 50 01 	call	0x2a0	; 0x2a0 <servo_1_free>
//Function to rotate Servo 2 by a specified angle in the multiples of 1.86 degrees
void servo_2(unsigned char degrees)
{
	float PositionTiltServo = 0;
	PositionTiltServo = ((float)degrees / 1.86) + 35.0;
	OCR1BH = 0x00;
     796:	10 92 8b 00 	sts	0x008B, r1	; 0x80008b <__TEXT_REGION_LENGTH__+0x70008b>
	OCR1BL = (unsigned char) PositionTiltServo;
     79a:	83 e4       	ldi	r24, 0x43	; 67
     79c:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <__TEXT_REGION_LENGTH__+0x70008a>
     7a0:	ef ef       	ldi	r30, 0xFF	; 255
     7a2:	ff e7       	ldi	r31, 0x7F	; 127
     7a4:	23 e4       	ldi	r18, 0x43	; 67
     7a6:	e1 50       	subi	r30, 0x01	; 1
     7a8:	f0 40       	sbci	r31, 0x00	; 0
     7aa:	20 40       	sbci	r18, 0x00	; 0
     7ac:	e1 f7       	brne	.-8      	; 0x7a6 <pickup_and_place+0x1e0>
     7ae:	00 c0       	rjmp	.+0      	; 0x7b0 <pickup_and_place+0x1ea>
     7b0:	00 00       	nop
		case 2: servo_1(23);//arm rotates to the specified angle
			_delay_ms(1500);
			servo_1_free();
			servo_2(60);//arm comes down to drop the object in container
			_delay_ms(1500);
			servo_2_free();
     7b2:	0e 94 57 01 	call	0x2ae	; 0x2ae <servo_2_free>
//Function to rotate Servo 3 by a specified angle in the multiples of 1.86 degrees
void servo_3(unsigned char degrees)
{
	float PositionServo = 0;
	PositionServo = ((float)degrees / 1.86) + 35.0;
	OCR1CH = 0x00;
     7b6:	10 92 8d 00 	sts	0x008D, r1	; 0x80008d <__TEXT_REGION_LENGTH__+0x70008d>
	OCR1CL = (unsigned char) PositionServo;
     7ba:	83 e2       	ldi	r24, 0x23	; 35
     7bc:	80 93 8c 00 	sts	0x008C, r24	; 0x80008c <__TEXT_REGION_LENGTH__+0x70008c>
     7c0:	8f ef       	ldi	r24, 0xFF	; 255
     7c2:	9f e7       	ldi	r25, 0x7F	; 127
     7c4:	e3 e4       	ldi	r30, 0x43	; 67
     7c6:	81 50       	subi	r24, 0x01	; 1
     7c8:	90 40       	sbci	r25, 0x00	; 0
     7ca:	e0 40       	sbci	r30, 0x00	; 0
     7cc:	e1 f7       	brne	.-8      	; 0x7c6 <pickup_and_place+0x200>
     7ce:	00 c0       	rjmp	.+0      	; 0x7d0 <pickup_and_place+0x20a>
     7d0:	00 00       	nop
			servo_2(60);//arm comes down to drop the object in container
			_delay_ms(1500);
			servo_2_free();
			servo_3(0);//flap opens and object is dropped
			_delay_ms(1500);
			servo_3_free();
     7d2:	0e 94 5e 01 	call	0x2bc	; 0x2bc <servo_3_free>
			initialize_servo();
     7d6:	0e 94 a9 02 	call	0x552	; 0x552 <initialize_servo>
			break;
     7da:	31 c0       	rjmp	.+98     	; 0x83e <pickup_and_place+0x278>
//Function to rotate Servo 1 by a specified angle in the multiples of 1.86 degrees
void servo_1(unsigned char degrees)
{
	float PositionPanServo = 0;
	PositionPanServo = ((float)degrees / 1.86) + 35.0;
	OCR1AH = 0x00;
     7dc:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
	OCR1AL = (unsigned char) PositionPanServo;
     7e0:	c3 e2       	ldi	r28, 0x23	; 35
     7e2:	c0 93 88 00 	sts	0x0088, r28	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
     7e6:	ff ef       	ldi	r31, 0xFF	; 255
     7e8:	2f e7       	ldi	r18, 0x7F	; 127
     7ea:	83 e4       	ldi	r24, 0x43	; 67
     7ec:	f1 50       	subi	r31, 0x01	; 1
     7ee:	20 40       	sbci	r18, 0x00	; 0
     7f0:	80 40       	sbci	r24, 0x00	; 0
     7f2:	e1 f7       	brne	.-8      	; 0x7ec <pickup_and_place+0x226>
     7f4:	00 c0       	rjmp	.+0      	; 0x7f6 <pickup_and_place+0x230>
     7f6:	00 00       	nop
			servo_3_free();
			initialize_servo();
			break;
		case 1: servo_1(0);//arm rotates to the specified angle
			_delay_ms(1500);
			servo_1_free();
     7f8:	0e 94 50 01 	call	0x2a0	; 0x2a0 <servo_1_free>
//Function to rotate Servo 2 by a specified angle in the multiples of 1.86 degrees
void servo_2(unsigned char degrees)
{
	float PositionTiltServo = 0;
	PositionTiltServo = ((float)degrees / 1.86) + 35.0;
	OCR1BH = 0x00;
     7fc:	10 92 8b 00 	sts	0x008B, r1	; 0x80008b <__TEXT_REGION_LENGTH__+0x70008b>
	OCR1BL = (unsigned char) PositionTiltServo;
     800:	8d e3       	ldi	r24, 0x3D	; 61
     802:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <__TEXT_REGION_LENGTH__+0x70008a>
     806:	9f ef       	ldi	r25, 0xFF	; 255
     808:	ef e7       	ldi	r30, 0x7F	; 127
     80a:	f3 e4       	ldi	r31, 0x43	; 67
     80c:	91 50       	subi	r25, 0x01	; 1
     80e:	e0 40       	sbci	r30, 0x00	; 0
     810:	f0 40       	sbci	r31, 0x00	; 0
     812:	e1 f7       	brne	.-8      	; 0x80c <pickup_and_place+0x246>
     814:	00 c0       	rjmp	.+0      	; 0x816 <pickup_and_place+0x250>
     816:	00 00       	nop
		case 1: servo_1(0);//arm rotates to the specified angle
			_delay_ms(1500);
			servo_1_free();
			servo_2(50);//arm comes down to drop the object in container
			_delay_ms(1500);
			servo_2_free();
     818:	0e 94 57 01 	call	0x2ae	; 0x2ae <servo_2_free>
//Function to rotate Servo 3 by a specified angle in the multiples of 1.86 degrees
void servo_3(unsigned char degrees)
{
	float PositionServo = 0;
	PositionServo = ((float)degrees / 1.86) + 35.0;
	OCR1CH = 0x00;
     81c:	10 92 8d 00 	sts	0x008D, r1	; 0x80008d <__TEXT_REGION_LENGTH__+0x70008d>
	OCR1CL = (unsigned char) PositionServo;
     820:	c0 93 8c 00 	sts	0x008C, r28	; 0x80008c <__TEXT_REGION_LENGTH__+0x70008c>
     824:	2f ef       	ldi	r18, 0xFF	; 255
     826:	8f e7       	ldi	r24, 0x7F	; 127
     828:	93 e4       	ldi	r25, 0x43	; 67
     82a:	21 50       	subi	r18, 0x01	; 1
     82c:	80 40       	sbci	r24, 0x00	; 0
     82e:	90 40       	sbci	r25, 0x00	; 0
     830:	e1 f7       	brne	.-8      	; 0x82a <pickup_and_place+0x264>
     832:	00 c0       	rjmp	.+0      	; 0x834 <pickup_and_place+0x26e>
     834:	00 00       	nop
			servo_2(50);//arm comes down to drop the object in container
			_delay_ms(1500);
			servo_2_free();
			servo_3(0);//flap opens and object is dropped
			_delay_ms(1500);
			servo_3_free();
     836:	0e 94 5e 01 	call	0x2bc	; 0x2bc <servo_3_free>
			initialize_servo();
     83a:	0e 94 a9 02 	call	0x552	; 0x552 <initialize_servo>
			break;			 
	}
	servo_1_free();
     83e:	0e 94 50 01 	call	0x2a0	; 0x2a0 <servo_1_free>
	servo_2_free();
     842:	0e 94 57 01 	call	0x2ae	; 0x2ae <servo_2_free>
	servo_3_free();
     846:	0e 94 5e 01 	call	0x2bc	; 0x2bc <servo_3_free>

}
     84a:	df 91       	pop	r29
     84c:	cf 91       	pop	r28
     84e:	1f 91       	pop	r17
     850:	0f 91       	pop	r16
     852:	ff 90       	pop	r15
     854:	ef 90       	pop	r14
     856:	08 95       	ret

00000858 <sense>:
Example call:sense()
*/
void sense()
{
	//checks for the ir sensor values and calls count_black_dots whenever a black dot is seen
	Left_white_line = ADC_Conversion(3);	//Getting data of Left WL Sensor
     858:	83 e0       	ldi	r24, 0x03	; 3
     85a:	0e 94 24 02 	call	0x448	; 0x448 <ADC_Conversion>
     85e:	80 93 15 02 	sts	0x0215, r24	; 0x800215 <Left_white_line>
	Center_white_line = ADC_Conversion(2);	//Getting data of Center WL Sensor
     862:	82 e0       	ldi	r24, 0x02	; 2
     864:	0e 94 24 02 	call	0x448	; 0x448 <ADC_Conversion>
     868:	80 93 14 02 	sts	0x0214, r24	; 0x800214 <Center_white_line>
	Right_white_line = ADC_Conversion(1);	//Getting data of Right WL Sensor
     86c:	81 e0       	ldi	r24, 0x01	; 1
     86e:	0e 94 24 02 	call	0x448	; 0x448 <ADC_Conversion>
     872:	80 93 13 02 	sts	0x0213, r24	; 0x800213 <Right_white_line>
	sharp_ir3=ADC_Conversion(11);			//getting data of sharp ir sensor in the front
     876:	8b e0       	ldi	r24, 0x0B	; 11
     878:	0e 94 24 02 	call	0x448	; 0x448 <ADC_Conversion>
     87c:	80 93 12 02 	sts	0x0212, r24	; 0x800212 <__data_end>
     880:	08 95       	ret

00000882 <moveforward>:
Output:no output
logic:this function will follow the white line until the specified no. of dots are not skipped
Example call:moveforward(2)
*/
void moveforward(int no_of_dots_to_be_skipped)
{
     882:	bf 92       	push	r11
     884:	cf 92       	push	r12
     886:	df 92       	push	r13
     888:	ef 92       	push	r14
     88a:	ff 92       	push	r15
     88c:	0f 93       	push	r16
     88e:	1f 93       	push	r17
     890:	cf 93       	push	r28
     892:	df 93       	push	r29
     894:	6c 01       	movw	r12, r24
	//move forward and dont stop  till skipped lines !=0 
	int count=0;//will count the no. of black dots passed.
     896:	e1 2c       	mov	r14, r1
     898:	f1 2c       	mov	r15, r1
}


void velocity (unsigned char left_motor, unsigned char right_motor)
{
	OCR5AL = (unsigned char)left_motor;
     89a:	08 e2       	ldi	r16, 0x28	; 40
     89c:	11 e0       	ldi	r17, 0x01	; 1
	OCR5BL = (unsigned char)right_motor;
     89e:	ca e2       	ldi	r28, 0x2A	; 42
     8a0:	d1 e0       	ldi	r29, 0x01	; 1
     8a2:	bb 24       	eor	r11, r11
     8a4:	ba 94       	dec	r11
{
	//move forward and dont stop  till skipped lines !=0 
	int count=0;//will count the no. of black dots passed.
	while(1)//code to follow black line
	{
		sense();
     8a6:	0e 94 2c 04 	call	0x858	; 0x858 <sense>
		if(Center_white_line>0x28)
     8aa:	80 91 14 02 	lds	r24, 0x0214	; 0x800214 <Center_white_line>
     8ae:	89 32       	cpi	r24, 0x29	; 41
     8b0:	30 f0       	brcs	.+12     	; 0x8be <moveforward+0x3c>
		{
			forward();
     8b2:	0e 94 4d 02 	call	0x49a	; 0x49a <forward>
}


void velocity (unsigned char left_motor, unsigned char right_motor)
{
	OCR5AL = (unsigned char)left_motor;
     8b6:	f8 01       	movw	r30, r16
     8b8:	b0 82       	st	Z, r11
	OCR5BL = (unsigned char)right_motor;
     8ba:	b8 82       	st	Y, r11
     8bc:	13 c0       	rjmp	.+38     	; 0x8e4 <moveforward+0x62>
		if(Center_white_line>0x28)
		{
			forward();
			velocity(255,255);
		}
		else if(Left_white_line<0x28)
     8be:	80 91 15 02 	lds	r24, 0x0215	; 0x800215 <Left_white_line>
     8c2:	88 32       	cpi	r24, 0x28	; 40
     8c4:	30 f4       	brcc	.+12     	; 0x8d2 <moveforward+0x50>
		{
			forward();
     8c6:	0e 94 4d 02 	call	0x49a	; 0x49a <forward>
}


void velocity (unsigned char left_motor, unsigned char right_motor)
{
	OCR5AL = (unsigned char)left_motor;
     8ca:	f8 01       	movw	r30, r16
     8cc:	b0 82       	st	Z, r11
	OCR5BL = (unsigned char)right_motor;
     8ce:	18 82       	st	Y, r1
     8d0:	09 c0       	rjmp	.+18     	; 0x8e4 <moveforward+0x62>
		else if(Left_white_line<0x28)
		{
			forward();
			velocity(255,0);
		}
		else if(Right_white_line<0x28)
     8d2:	80 91 13 02 	lds	r24, 0x0213	; 0x800213 <Right_white_line>
     8d6:	88 32       	cpi	r24, 0x28	; 40
     8d8:	28 f4       	brcc	.+10     	; 0x8e4 <moveforward+0x62>
		{
			forward();
     8da:	0e 94 4d 02 	call	0x49a	; 0x49a <forward>
}


void velocity (unsigned char left_motor, unsigned char right_motor)
{
	OCR5AL = (unsigned char)left_motor;
     8de:	f8 01       	movw	r30, r16
     8e0:	10 82       	st	Z, r1
	OCR5BL = (unsigned char)right_motor;
     8e2:	b8 82       	st	Y, r11
		else if(Right_white_line<0x28)
		{
			forward();
			velocity(0,255);
		}
		if(Center_white_line+Left_white_line+Right_white_line>0xB4)
     8e4:	20 91 14 02 	lds	r18, 0x0214	; 0x800214 <Center_white_line>
     8e8:	80 91 15 02 	lds	r24, 0x0215	; 0x800215 <Left_white_line>
     8ec:	90 e0       	ldi	r25, 0x00	; 0
     8ee:	82 0f       	add	r24, r18
     8f0:	91 1d       	adc	r25, r1
     8f2:	20 91 13 02 	lds	r18, 0x0213	; 0x800213 <Right_white_line>
     8f6:	82 0f       	add	r24, r18
     8f8:	91 1d       	adc	r25, r1
     8fa:	85 3b       	cpi	r24, 0xB5	; 181
     8fc:	91 05       	cpc	r25, r1
     8fe:	9c f2       	brlt	.-90     	; 0x8a6 <moveforward+0x24>
		{
			/*initially when bot will be at the starting position it will rotate towards its
			first position and then will continue its path,after reaching the edge,bot has to rotate 
			a little more on 1,4,5,8,9 and 12 to calibrate that the below if condition is used
			*/
			if((current_object%4==0||(current_object-1)%4==0)&& current_object!=0)
     900:	80 91 26 02 	lds	r24, 0x0226	; 0x800226 <current_object>
     904:	90 91 27 02 	lds	r25, 0x0227	; 0x800227 <current_object+0x1>
     908:	9c 01       	movw	r18, r24
     90a:	23 70       	andi	r18, 0x03	; 3
     90c:	33 27       	eor	r19, r19
     90e:	23 2b       	or	r18, r19
     910:	39 f0       	breq	.+14     	; 0x920 <moveforward+0x9e>
     912:	9c 01       	movw	r18, r24
     914:	21 50       	subi	r18, 0x01	; 1
     916:	31 09       	sbc	r19, r1
     918:	23 70       	andi	r18, 0x03	; 3
     91a:	33 27       	eor	r19, r19
     91c:	23 2b       	or	r18, r19
     91e:	39 f4       	brne	.+14     	; 0x92e <moveforward+0xac>
     920:	89 2b       	or	r24, r25
     922:	29 f0       	breq	.+10     	; 0x92e <moveforward+0xac>
			{
				forward_mm(10);
     924:	8a e0       	ldi	r24, 0x0A	; 10
     926:	90 e0       	ldi	r25, 0x00	; 0
     928:	0e 94 88 02 	call	0x510	; 0x510 <forward_mm>
     92c:	04 c0       	rjmp	.+8      	; 0x936 <moveforward+0xb4>
			}
			else
			{
				forward_mm(50);
     92e:	82 e3       	ldi	r24, 0x32	; 50
     930:	90 e0       	ldi	r25, 0x00	; 0
     932:	0e 94 88 02 	call	0x510	; 0x510 <forward_mm>
			}
			if(count>=no_of_dots_to_be_skipped)
     936:	ec 14       	cp	r14, r12
     938:	fd 04       	cpc	r15, r13
     93a:	a4 f0       	brlt	.+40     	; 0x964 <moveforward+0xe2>
			{
				
				current_object=0;//to null the effect of above  if((current_object%4==0||(current_object-1)%4==0)&& current_object!=0) condition after the edge rotation is performed,it is set to 0.current object will again be given new value when bot will come from starting position to any of the object positions   
     93c:	10 92 27 02 	sts	0x0227, r1	; 0x800227 <current_object+0x1>
     940:	10 92 26 02 	sts	0x0226, r1	; 0x800226 <current_object>
				stop();
     944:	0e 94 5d 02 	call	0x4ba	; 0x4ba <stop>
}


void velocity (unsigned char left_motor, unsigned char right_motor)
{
	OCR5AL = (unsigned char)left_motor;
     948:	10 92 28 01 	sts	0x0128, r1	; 0x800128 <__TEXT_REGION_LENGTH__+0x700128>
	OCR5BL = (unsigned char)right_motor;
     94c:	10 92 2a 01 	sts	0x012A, r1	; 0x80012a <__TEXT_REGION_LENGTH__+0x70012a>
     950:	ff ef       	ldi	r31, 0xFF	; 255
     952:	2f e7       	ldi	r18, 0x7F	; 127
     954:	86 e1       	ldi	r24, 0x16	; 22
     956:	f1 50       	subi	r31, 0x01	; 1
     958:	20 40       	sbci	r18, 0x00	; 0
     95a:	80 40       	sbci	r24, 0x00	; 0
     95c:	e1 f7       	brne	.-8      	; 0x956 <moveforward+0xd4>
     95e:	00 c0       	rjmp	.+0      	; 0x960 <moveforward+0xde>
     960:	00 00       	nop
				break;
			}
			count++;
		}			
	}
}
     962:	04 c0       	rjmp	.+8      	; 0x96c <moveforward+0xea>
				stop();
				velocity(0,0);
				_delay_ms(500);
				break;
			}
			count++;
     964:	9f ef       	ldi	r25, 0xFF	; 255
     966:	e9 1a       	sub	r14, r25
     968:	f9 0a       	sbc	r15, r25
     96a:	9d cf       	rjmp	.-198    	; 0x8a6 <moveforward+0x24>
		}			
	}
}
     96c:	df 91       	pop	r29
     96e:	cf 91       	pop	r28
     970:	1f 91       	pop	r17
     972:	0f 91       	pop	r16
     974:	ff 90       	pop	r15
     976:	ef 90       	pop	r14
     978:	df 90       	pop	r13
     97a:	cf 90       	pop	r12
     97c:	bf 90       	pop	r11
     97e:	08 95       	ret

00000980 <rotate_clockwise>:
Output:no output
logic:this function will rotate the robot in clockwise direction till the specified no. of lines are not skipped 
Example call:rotate_clockwise(1)
*/
void rotate_clockwise(unsigned int lines_to_be_skipped)
{
     980:	ef 92       	push	r14
     982:	ff 92       	push	r15
     984:	0f 93       	push	r16
     986:	1f 93       	push	r17
     988:	cf 93       	push	r28
     98a:	df 93       	push	r29
     98c:	ec 01       	movw	r28, r24
	//rotate clockwise and dont stop  till skipped lines !=0 
	right();
     98e:	0e 94 59 02 	call	0x4b2	; 0x4b2 <right>
}


void velocity (unsigned char left_motor, unsigned char right_motor)
{
	OCR5AL = (unsigned char)left_motor;
     992:	86 e9       	ldi	r24, 0x96	; 150
     994:	80 93 28 01 	sts	0x0128, r24	; 0x800128 <__TEXT_REGION_LENGTH__+0x700128>
	OCR5BL = (unsigned char)right_motor;
     998:	80 93 2a 01 	sts	0x012A, r24	; 0x80012a <__TEXT_REGION_LENGTH__+0x70012a>
void rotate_clockwise(unsigned int lines_to_be_skipped)
{
	//rotate clockwise and dont stop  till skipped lines !=0 
	right();
	velocity(150,150);
	while(lines_to_be_skipped>0)
     99c:	20 97       	sbiw	r28, 0x00	; 0
     99e:	c1 f0       	breq	.+48     	; 0x9d0 <rotate_clockwise+0x50>
     9a0:	2f ef       	ldi	r18, 0xFF	; 255
     9a2:	8f e7       	ldi	r24, 0x7F	; 127
     9a4:	9d e0       	ldi	r25, 0x0D	; 13
     9a6:	21 50       	subi	r18, 0x01	; 1
     9a8:	80 40       	sbci	r24, 0x00	; 0
     9aa:	90 40       	sbci	r25, 0x00	; 0
     9ac:	e1 f7       	brne	.-8      	; 0x9a6 <rotate_clockwise+0x26>
     9ae:	00 c0       	rjmp	.+0      	; 0x9b0 <rotate_clockwise+0x30>
     9b0:	00 00       	nop
	{
		_delay_ms(300);
		lines_to_be_skipped--;
     9b2:	21 97       	sbiw	r28, 0x01	; 1
		sense();
     9b4:	0e 94 2c 04 	call	0x858	; 0x858 <sense>
		while(Right_white_line<0x20)
     9b8:	80 91 13 02 	lds	r24, 0x0213	; 0x800213 <Right_white_line>
     9bc:	80 32       	cpi	r24, 0x20	; 32
     9be:	30 f4       	brcc	.+12     	; 0x9cc <rotate_clockwise+0x4c>
		{
			sense();
     9c0:	0e 94 2c 04 	call	0x858	; 0x858 <sense>
	while(lines_to_be_skipped>0)
	{
		_delay_ms(300);
		lines_to_be_skipped--;
		sense();
		while(Right_white_line<0x20)
     9c4:	80 91 13 02 	lds	r24, 0x0213	; 0x800213 <Right_white_line>
     9c8:	80 32       	cpi	r24, 0x20	; 32
     9ca:	d0 f3       	brcs	.-12     	; 0x9c0 <rotate_clockwise+0x40>
void rotate_clockwise(unsigned int lines_to_be_skipped)
{
	//rotate clockwise and dont stop  till skipped lines !=0 
	right();
	velocity(150,150);
	while(lines_to_be_skipped>0)
     9cc:	20 97       	sbiw	r28, 0x00	; 0
     9ce:	41 f7       	brne	.-48     	; 0x9a0 <rotate_clockwise+0x20>
		while(Right_white_line<0x20)
		{
			sense();
		}
	}
	stop();
     9d0:	0e 94 5d 02 	call	0x4ba	; 0x4ba <stop>
     9d4:	ef ef       	ldi	r30, 0xFF	; 255
     9d6:	ff e7       	ldi	r31, 0x7F	; 127
     9d8:	26 e1       	ldi	r18, 0x16	; 22
     9da:	e1 50       	subi	r30, 0x01	; 1
     9dc:	f0 40       	sbci	r31, 0x00	; 0
     9de:	20 40       	sbci	r18, 0x00	; 0
     9e0:	e1 f7       	brne	.-8      	; 0x9da <rotate_clockwise+0x5a>
     9e2:	00 c0       	rjmp	.+0      	; 0x9e4 <rotate_clockwise+0x64>
     9e4:	00 00       	nop
	_delay_ms(500);
	sense();
     9e6:	0e 94 2c 04 	call	0x858	; 0x858 <sense>
	//condition if by chance the robot has moved more than desired
	while(Center_white_line<0x20 && Left_white_line>0x20)
     9ea:	80 91 14 02 	lds	r24, 0x0214	; 0x800214 <Center_white_line>
     9ee:	80 32       	cpi	r24, 0x20	; 32
     9f0:	e8 f4       	brcc	.+58     	; 0xa2c <rotate_clockwise+0xac>
     9f2:	80 91 15 02 	lds	r24, 0x0215	; 0x800215 <Left_white_line>
     9f6:	81 32       	cpi	r24, 0x21	; 33
     9f8:	c8 f0       	brcs	.+50     	; 0xa2c <rotate_clockwise+0xac>
}


void velocity (unsigned char left_motor, unsigned char right_motor)
{
	OCR5AL = (unsigned char)left_motor;
     9fa:	0f 2e       	mov	r0, r31
     9fc:	f8 e2       	ldi	r31, 0x28	; 40
     9fe:	ef 2e       	mov	r14, r31
     a00:	ff 24       	eor	r15, r15
     a02:	f3 94       	inc	r15
     a04:	f0 2d       	mov	r31, r0
     a06:	c6 e9       	ldi	r28, 0x96	; 150
	OCR5BL = (unsigned char)right_motor;
     a08:	0a e2       	ldi	r16, 0x2A	; 42
     a0a:	11 e0       	ldi	r17, 0x01	; 1
	_delay_ms(500);
	sense();
	//condition if by chance the robot has moved more than desired
	while(Center_white_line<0x20 && Left_white_line>0x20)
	{
		sense();
     a0c:	0e 94 2c 04 	call	0x858	; 0x858 <sense>
		left();
     a10:	0e 94 55 02 	call	0x4aa	; 0x4aa <left>
}


void velocity (unsigned char left_motor, unsigned char right_motor)
{
	OCR5AL = (unsigned char)left_motor;
     a14:	f7 01       	movw	r30, r14
     a16:	c0 83       	st	Z, r28
	OCR5BL = (unsigned char)right_motor;
     a18:	f8 01       	movw	r30, r16
     a1a:	c0 83       	st	Z, r28
	}
	stop();
	_delay_ms(500);
	sense();
	//condition if by chance the robot has moved more than desired
	while(Center_white_line<0x20 && Left_white_line>0x20)
     a1c:	80 91 14 02 	lds	r24, 0x0214	; 0x800214 <Center_white_line>
     a20:	80 32       	cpi	r24, 0x20	; 32
     a22:	20 f4       	brcc	.+8      	; 0xa2c <rotate_clockwise+0xac>
     a24:	80 91 15 02 	lds	r24, 0x0215	; 0x800215 <Left_white_line>
     a28:	81 32       	cpi	r24, 0x21	; 33
     a2a:	80 f7       	brcc	.-32     	; 0xa0c <rotate_clockwise+0x8c>
	{
		sense();
		left();
		velocity(150,150);
	}
	stop();
     a2c:	0e 94 5d 02 	call	0x4ba	; 0x4ba <stop>
     a30:	ff ef       	ldi	r31, 0xFF	; 255
     a32:	2f e7       	ldi	r18, 0x7F	; 127
     a34:	86 e1       	ldi	r24, 0x16	; 22
     a36:	f1 50       	subi	r31, 0x01	; 1
     a38:	20 40       	sbci	r18, 0x00	; 0
     a3a:	80 40       	sbci	r24, 0x00	; 0
     a3c:	e1 f7       	brne	.-8      	; 0xa36 <rotate_clockwise+0xb6>
     a3e:	00 c0       	rjmp	.+0      	; 0xa40 <rotate_clockwise+0xc0>
     a40:	00 00       	nop
	_delay_ms(500);
	
}
     a42:	df 91       	pop	r29
     a44:	cf 91       	pop	r28
     a46:	1f 91       	pop	r17
     a48:	0f 91       	pop	r16
     a4a:	ff 90       	pop	r15
     a4c:	ef 90       	pop	r14
     a4e:	08 95       	ret

00000a50 <rotate_anticlockwise>:
Output:no output
logic:this function will rotate the robot in anticlockwise direction till the specified no. of lines are not skipped 
Example call:rotate_anticlockwise(1)
*/
void rotate_anticlockwise(unsigned int lines_to_be_skipped)
{
     a50:	ef 92       	push	r14
     a52:	ff 92       	push	r15
     a54:	0f 93       	push	r16
     a56:	1f 93       	push	r17
     a58:	cf 93       	push	r28
     a5a:	df 93       	push	r29
     a5c:	ec 01       	movw	r28, r24
	left();
     a5e:	0e 94 55 02 	call	0x4aa	; 0x4aa <left>
}


void velocity (unsigned char left_motor, unsigned char right_motor)
{
	OCR5AL = (unsigned char)left_motor;
     a62:	86 e9       	ldi	r24, 0x96	; 150
     a64:	80 93 28 01 	sts	0x0128, r24	; 0x800128 <__TEXT_REGION_LENGTH__+0x700128>
	OCR5BL = (unsigned char)right_motor;
     a68:	80 93 2a 01 	sts	0x012A, r24	; 0x80012a <__TEXT_REGION_LENGTH__+0x70012a>
*/
void rotate_anticlockwise(unsigned int lines_to_be_skipped)
{
	left();
	velocity(150,150);
	while(lines_to_be_skipped>0)
     a6c:	20 97       	sbiw	r28, 0x00	; 0
     a6e:	c1 f0       	breq	.+48     	; 0xaa0 <rotate_anticlockwise+0x50>
     a70:	2f ef       	ldi	r18, 0xFF	; 255
     a72:	8f e7       	ldi	r24, 0x7F	; 127
     a74:	9d e0       	ldi	r25, 0x0D	; 13
     a76:	21 50       	subi	r18, 0x01	; 1
     a78:	80 40       	sbci	r24, 0x00	; 0
     a7a:	90 40       	sbci	r25, 0x00	; 0
     a7c:	e1 f7       	brne	.-8      	; 0xa76 <rotate_anticlockwise+0x26>
     a7e:	00 c0       	rjmp	.+0      	; 0xa80 <rotate_anticlockwise+0x30>
     a80:	00 00       	nop
	{
		_delay_ms(300);
		lines_to_be_skipped--;
     a82:	21 97       	sbiw	r28, 0x01	; 1
		sense();
     a84:	0e 94 2c 04 	call	0x858	; 0x858 <sense>
		while(Left_white_line<0x20)
     a88:	80 91 15 02 	lds	r24, 0x0215	; 0x800215 <Left_white_line>
     a8c:	80 32       	cpi	r24, 0x20	; 32
     a8e:	30 f4       	brcc	.+12     	; 0xa9c <rotate_anticlockwise+0x4c>
		{
			sense();
     a90:	0e 94 2c 04 	call	0x858	; 0x858 <sense>
	while(lines_to_be_skipped>0)
	{
		_delay_ms(300);
		lines_to_be_skipped--;
		sense();
		while(Left_white_line<0x20)
     a94:	80 91 15 02 	lds	r24, 0x0215	; 0x800215 <Left_white_line>
     a98:	80 32       	cpi	r24, 0x20	; 32
     a9a:	d0 f3       	brcs	.-12     	; 0xa90 <rotate_anticlockwise+0x40>
*/
void rotate_anticlockwise(unsigned int lines_to_be_skipped)
{
	left();
	velocity(150,150);
	while(lines_to_be_skipped>0)
     a9c:	20 97       	sbiw	r28, 0x00	; 0
     a9e:	41 f7       	brne	.-48     	; 0xa70 <rotate_anticlockwise+0x20>
		while(Left_white_line<0x20)
		{
			sense();
		}
	}
	stop();
     aa0:	0e 94 5d 02 	call	0x4ba	; 0x4ba <stop>
     aa4:	ef ef       	ldi	r30, 0xFF	; 255
     aa6:	ff e7       	ldi	r31, 0x7F	; 127
     aa8:	26 e1       	ldi	r18, 0x16	; 22
     aaa:	e1 50       	subi	r30, 0x01	; 1
     aac:	f0 40       	sbci	r31, 0x00	; 0
     aae:	20 40       	sbci	r18, 0x00	; 0
     ab0:	e1 f7       	brne	.-8      	; 0xaaa <rotate_anticlockwise+0x5a>
     ab2:	00 c0       	rjmp	.+0      	; 0xab4 <rotate_anticlockwise+0x64>
     ab4:	00 00       	nop
	_delay_ms(500);
	sense();
     ab6:	0e 94 2c 04 	call	0x858	; 0x858 <sense>
	//condition if by chance the robot has moved more than desired
	while(Center_white_line<0x20 && Right_white_line>0x20)
     aba:	80 91 14 02 	lds	r24, 0x0214	; 0x800214 <Center_white_line>
     abe:	80 32       	cpi	r24, 0x20	; 32
     ac0:	e8 f4       	brcc	.+58     	; 0xafc <rotate_anticlockwise+0xac>
     ac2:	80 91 13 02 	lds	r24, 0x0213	; 0x800213 <Right_white_line>
     ac6:	81 32       	cpi	r24, 0x21	; 33
     ac8:	c8 f0       	brcs	.+50     	; 0xafc <rotate_anticlockwise+0xac>
}


void velocity (unsigned char left_motor, unsigned char right_motor)
{
	OCR5AL = (unsigned char)left_motor;
     aca:	0f 2e       	mov	r0, r31
     acc:	f8 e2       	ldi	r31, 0x28	; 40
     ace:	ef 2e       	mov	r14, r31
     ad0:	ff 24       	eor	r15, r15
     ad2:	f3 94       	inc	r15
     ad4:	f0 2d       	mov	r31, r0
     ad6:	c6 e9       	ldi	r28, 0x96	; 150
	OCR5BL = (unsigned char)right_motor;
     ad8:	0a e2       	ldi	r16, 0x2A	; 42
     ada:	11 e0       	ldi	r17, 0x01	; 1
	_delay_ms(500);
	sense();
	//condition if by chance the robot has moved more than desired
	while(Center_white_line<0x20 && Right_white_line>0x20)
	{
		sense();
     adc:	0e 94 2c 04 	call	0x858	; 0x858 <sense>
		right();
     ae0:	0e 94 59 02 	call	0x4b2	; 0x4b2 <right>
}


void velocity (unsigned char left_motor, unsigned char right_motor)
{
	OCR5AL = (unsigned char)left_motor;
     ae4:	f7 01       	movw	r30, r14
     ae6:	c0 83       	st	Z, r28
	OCR5BL = (unsigned char)right_motor;
     ae8:	f8 01       	movw	r30, r16
     aea:	c0 83       	st	Z, r28
	}
	stop();
	_delay_ms(500);
	sense();
	//condition if by chance the robot has moved more than desired
	while(Center_white_line<0x20 && Right_white_line>0x20)
     aec:	80 91 14 02 	lds	r24, 0x0214	; 0x800214 <Center_white_line>
     af0:	80 32       	cpi	r24, 0x20	; 32
     af2:	20 f4       	brcc	.+8      	; 0xafc <rotate_anticlockwise+0xac>
     af4:	80 91 13 02 	lds	r24, 0x0213	; 0x800213 <Right_white_line>
     af8:	81 32       	cpi	r24, 0x21	; 33
     afa:	80 f7       	brcc	.-32     	; 0xadc <rotate_anticlockwise+0x8c>
	{
		sense();
		right();
		velocity(150,150);
	}
	stop();
     afc:	0e 94 5d 02 	call	0x4ba	; 0x4ba <stop>
     b00:	ff ef       	ldi	r31, 0xFF	; 255
     b02:	2f e7       	ldi	r18, 0x7F	; 127
     b04:	86 e1       	ldi	r24, 0x16	; 22
     b06:	f1 50       	subi	r31, 0x01	; 1
     b08:	20 40       	sbci	r18, 0x00	; 0
     b0a:	80 40       	sbci	r24, 0x00	; 0
     b0c:	e1 f7       	brne	.-8      	; 0xb06 <rotate_anticlockwise+0xb6>
     b0e:	00 c0       	rjmp	.+0      	; 0xb10 <rotate_anticlockwise+0xc0>
     b10:	00 00       	nop
	_delay_ms(500);
}
     b12:	df 91       	pop	r29
     b14:	cf 91       	pop	r28
     b16:	1f 91       	pop	r17
     b18:	0f 91       	pop	r16
     b1a:	ff 90       	pop	r15
     b1c:	ef 90       	pop	r14
     b1e:	08 95       	ret

00000b20 <get_back_on_track>:
Example call:get_back_on_track()
*/
void get_back_on_track()
{
	//gets the bot back on track when the object is picked up
	rotate_clockwise(1);//since the robot is picking the object in ascending order so everytime will rotate clockwise to go to next bigger position 
     b20:	81 e0       	ldi	r24, 0x01	; 1
     b22:	90 e0       	ldi	r25, 0x00	; 0
     b24:	0e 94 c0 04 	call	0x980	; 0x980 <rotate_clockwise>
     b28:	08 95       	ret

00000b2a <place_container_on_rotating_structure>:
Output:no output
logic:this function will place the bot back on the rotating structure 
Example call:place_container_on_rotating_structure
*/
void place_container_on_rotating_structure(int empty_container_position)
{
     b2a:	2f 92       	push	r2
     b2c:	3f 92       	push	r3
     b2e:	4f 92       	push	r4
     b30:	5f 92       	push	r5
     b32:	6f 92       	push	r6
     b34:	7f 92       	push	r7
     b36:	8f 92       	push	r8
     b38:	9f 92       	push	r9
     b3a:	af 92       	push	r10
     b3c:	bf 92       	push	r11
     b3e:	cf 92       	push	r12
     b40:	df 92       	push	r13
     b42:	ef 92       	push	r14
     b44:	ff 92       	push	r15
     b46:	0f 93       	push	r16
     b48:	1f 93       	push	r17
     b4a:	cf 93       	push	r28
     b4c:	df 93       	push	r29
     b4e:	7c 01       	movw	r14, r24
logic:sends the signal multiple times since it may be possible zigbee on the other hand might not recieve the signal send from here
Example call:send('A')
*/
void send(unsigned char data_to_be_sent)//function to send data
{
		UDR0=data_to_be_sent;
     b50:	8d e4       	ldi	r24, 0x4D	; 77
     b52:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
     b56:	2f ef       	ldi	r18, 0xFF	; 255
     b58:	8f eb       	ldi	r24, 0xBF	; 191
     b5a:	96 e0       	ldi	r25, 0x06	; 6
     b5c:	21 50       	subi	r18, 0x01	; 1
     b5e:	80 40       	sbci	r24, 0x00	; 0
     b60:	90 40       	sbci	r25, 0x00	; 0
     b62:	e1 f7       	brne	.-8      	; 0xb5c <place_container_on_rotating_structure+0x32>
     b64:	00 c0       	rjmp	.+0      	; 0xb66 <place_container_on_rotating_structure+0x3c>
     b66:	00 00       	nop
void place_container_on_rotating_structure(int empty_container_position)
{
	
	send('M');//message to place containers on the truck
	_delay_ms(150);
	int i_copy=i-1;//copy of the initial position
     b68:	80 91 20 02 	lds	r24, 0x0220	; 0x800220 <i>
     b6c:	90 91 21 02 	lds	r25, 0x0221	; 0x800221 <i+0x1>
     b70:	6c 01       	movw	r12, r24
     b72:	e1 e0       	ldi	r30, 0x01	; 1
     b74:	ce 1a       	sub	r12, r30
     b76:	d1 08       	sbc	r13, r1
	//place the blocks on rotating structure,refer to the array for any required information
	
	if(empty_container_position<=0)//i.e. if one object is held in arm only
     b78:	1e 14       	cp	r1, r14
     b7a:	1f 04       	cpc	r1, r15
     b7c:	7c f1       	brlt	.+94     	; 0xbdc <place_container_on_rotating_structure+0xb2>
	{
		send(colour_sequence[i_copy]);
     b7e:	f6 01       	movw	r30, r12
     b80:	e0 50       	subi	r30, 0x00	; 0
     b82:	fe 4f       	sbci	r31, 0xFE	; 254
     b84:	20 81       	ld	r18, Z
logic:sends the signal multiple times since it may be possible zigbee on the other hand might not recieve the signal send from here
Example call:send('A')
*/
void send(unsigned char data_to_be_sent)//function to send data
{
		UDR0=data_to_be_sent;
     b86:	20 93 c6 00 	sts	0x00C6, r18	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
	//place the blocks on rotating structure,refer to the array for any required information
	
	if(empty_container_position<=0)//i.e. if one object is held in arm only
	{
		send(colour_sequence[i_copy]);
		i_copy--;
     b8a:	6c 01       	movw	r12, r24
     b8c:	f2 e0       	ldi	r31, 0x02	; 2
     b8e:	cf 1a       	sub	r12, r31
     b90:	d1 08       	sbc	r13, r1
     b92:	2f ef       	ldi	r18, 0xFF	; 255
     b94:	8f ef       	ldi	r24, 0xFF	; 255
     b96:	90 ee       	ldi	r25, 0xE0	; 224
     b98:	21 50       	subi	r18, 0x01	; 1
     b9a:	80 40       	sbci	r24, 0x00	; 0
     b9c:	90 40       	sbci	r25, 0x00	; 0
     b9e:	e1 f7       	brne	.-8      	; 0xb98 <place_container_on_rotating_structure+0x6e>
     ba0:	00 c0       	rjmp	.+0      	; 0xba2 <place_container_on_rotating_structure+0x78>
     ba2:	00 00       	nop
//Function to rotate Servo 2 by a specified angle in the multiples of 1.86 degrees
void servo_2(unsigned char degrees)
{
	float PositionTiltServo = 0;
	PositionTiltServo = ((float)degrees / 1.86) + 35.0;
	OCR1BH = 0x00;
     ba4:	10 92 8b 00 	sts	0x008B, r1	; 0x80008b <__TEXT_REGION_LENGTH__+0x70008b>
	OCR1BL = (unsigned char) PositionTiltServo;
     ba8:	88 e4       	ldi	r24, 0x48	; 72
     baa:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <__TEXT_REGION_LENGTH__+0x70008a>
     bae:	ef ef       	ldi	r30, 0xFF	; 255
     bb0:	ff e7       	ldi	r31, 0x7F	; 127
     bb2:	23 e4       	ldi	r18, 0x43	; 67
     bb4:	e1 50       	subi	r30, 0x01	; 1
     bb6:	f0 40       	sbci	r31, 0x00	; 0
     bb8:	20 40       	sbci	r18, 0x00	; 0
     bba:	e1 f7       	brne	.-8      	; 0xbb4 <place_container_on_rotating_structure+0x8a>
     bbc:	00 c0       	rjmp	.+0      	; 0xbbe <place_container_on_rotating_structure+0x94>
     bbe:	00 00       	nop
//Function to rotate Servo 3 by a specified angle in the multiples of 1.86 degrees
void servo_3(unsigned char degrees)
{
	float PositionServo = 0;
	PositionServo = ((float)degrees / 1.86) + 35.0;
	OCR1CH = 0x00;
     bc0:	10 92 8d 00 	sts	0x008D, r1	; 0x80008d <__TEXT_REGION_LENGTH__+0x70008d>
	OCR1CL = (unsigned char) PositionServo;
     bc4:	83 e2       	ldi	r24, 0x23	; 35
     bc6:	80 93 8c 00 	sts	0x008C, r24	; 0x80008c <__TEXT_REGION_LENGTH__+0x70008c>
     bca:	8f ef       	ldi	r24, 0xFF	; 255
     bcc:	9f e7       	ldi	r25, 0x7F	; 127
     bce:	e3 e4       	ldi	r30, 0x43	; 67
     bd0:	81 50       	subi	r24, 0x01	; 1
     bd2:	90 40       	sbci	r25, 0x00	; 0
     bd4:	e0 40       	sbci	r30, 0x00	; 0
     bd6:	e1 f7       	brne	.-8      	; 0xbd0 <place_container_on_rotating_structure+0xa6>
     bd8:	00 c0       	rjmp	.+0      	; 0xbda <place_container_on_rotating_structure+0xb0>
     bda:	00 00       	nop
		_delay_ms(1500);
		servo_3(0);//arm drops the object
		_delay_ms(1500);
		
	}
		initialize_servo();
     bdc:	0e 94 a9 02 	call	0x552	; 0x552 <initialize_servo>
		while(empty_container_position<=4)//empty_container_position will give the last container position where object was placed and then with fall through in switch arm will pickup object from that container as well as all the other previously filled 
     be0:	f5 e0       	ldi	r31, 0x05	; 5
     be2:	ef 16       	cp	r14, r31
     be4:	f1 04       	cpc	r15, r1
     be6:	0c f0       	brlt	.+2      	; 0xbea <place_container_on_rotating_structure+0xc0>
     be8:	fc c1       	rjmp	.+1016   	; 0xfe2 <place_container_on_rotating_structure+0x4b8>
     bea:	87 01       	movw	r16, r14
     bec:	2f ef       	ldi	r18, 0xFF	; 255
     bee:	e2 1a       	sub	r14, r18
     bf0:	f2 0a       	sbc	r15, r18
//Function to rotate Servo 1 by a specified angle in the multiples of 1.86 degrees
void servo_1(unsigned char degrees)
{
	float PositionPanServo = 0;
	PositionPanServo = ((float)degrees / 1.86) + 35.0;
	OCR1AH = 0x00;
     bf2:	0f 2e       	mov	r0, r31
     bf4:	f9 e8       	ldi	r31, 0x89	; 137
     bf6:	6f 2e       	mov	r6, r31
     bf8:	71 2c       	mov	r7, r1
     bfa:	f0 2d       	mov	r31, r0
	OCR1AL = (unsigned char) PositionPanServo;
     bfc:	0f 2e       	mov	r0, r31
     bfe:	f8 e8       	ldi	r31, 0x88	; 136
     c00:	4f 2e       	mov	r4, r31
     c02:	51 2c       	mov	r5, r1
     c04:	f0 2d       	mov	r31, r0
//Function to rotate Servo 2 by a specified angle in the multiples of 1.86 degrees
void servo_2(unsigned char degrees)
{
	float PositionTiltServo = 0;
	PositionTiltServo = ((float)degrees / 1.86) + 35.0;
	OCR1BH = 0x00;
     c06:	0f 2e       	mov	r0, r31
     c08:	fb e8       	ldi	r31, 0x8B	; 139
     c0a:	8f 2e       	mov	r8, r31
     c0c:	91 2c       	mov	r9, r1
     c0e:	f0 2d       	mov	r31, r0
	OCR1BL = (unsigned char) PositionTiltServo;
     c10:	0f 2e       	mov	r0, r31
     c12:	fa e8       	ldi	r31, 0x8A	; 138
     c14:	af 2e       	mov	r10, r31
     c16:	b1 2c       	mov	r11, r1
     c18:	f0 2d       	mov	r31, r0
//Function to rotate Servo 3 by a specified angle in the multiples of 1.86 degrees
void servo_3(unsigned char degrees)
{
	float PositionServo = 0;
	PositionServo = ((float)degrees / 1.86) + 35.0;
	OCR1CH = 0x00;
     c1a:	0f 2e       	mov	r0, r31
     c1c:	fd e8       	ldi	r31, 0x8D	; 141
     c1e:	2f 2e       	mov	r2, r31
     c20:	31 2c       	mov	r3, r1
     c22:	f0 2d       	mov	r31, r0
     c24:	05 c0       	rjmp	.+10     	; 0xc30 <place_container_on_rotating_structure+0x106>
     c26:	0f 5f       	subi	r16, 0xFF	; 255
     c28:	1f 4f       	sbci	r17, 0xFF	; 255
     c2a:	8f ef       	ldi	r24, 0xFF	; 255
     c2c:	e8 1a       	sub	r14, r24
     c2e:	f8 0a       	sbc	r15, r24
     c30:	e8 01       	movw	r28, r16
	}
		initialize_servo();
		while(empty_container_position<=4)//empty_container_position will give the last container position where object was placed and then with fall through in switch arm will pickup object from that container as well as all the other previously filled 
		{
			
			if(empty_container_position==4)
     c32:	04 30       	cpi	r16, 0x04	; 4
     c34:	11 05       	cpc	r17, r1
     c36:	09 f0       	breq	.+2      	; 0xc3a <place_container_on_rotating_structure+0x110>
     c38:	71 c0       	rjmp	.+226    	; 0xd1c <place_container_on_rotating_structure+0x1f2>
			{
				send(colour_sequence[i_copy]);
     c3a:	f6 01       	movw	r30, r12
     c3c:	e0 50       	subi	r30, 0x00	; 0
     c3e:	fe 4f       	sbci	r31, 0xFE	; 254
     c40:	80 81       	ld	r24, Z
logic:sends the signal multiple times since it may be possible zigbee on the other hand might not recieve the signal send from here
Example call:send('A')
*/
void send(unsigned char data_to_be_sent)//function to send data
{
		UDR0=data_to_be_sent;
     c42:	e6 ec       	ldi	r30, 0xC6	; 198
     c44:	f0 e0       	ldi	r31, 0x00	; 0
     c46:	80 83       	st	Z, r24
		{
			
			if(empty_container_position==4)
			{
				send(colour_sequence[i_copy]);
				i_copy--;
     c48:	f1 e0       	ldi	r31, 0x01	; 1
     c4a:	cf 1a       	sub	r12, r31
     c4c:	d1 08       	sbc	r13, r1
     c4e:	2f ef       	ldi	r18, 0xFF	; 255
     c50:	8f e7       	ldi	r24, 0x7F	; 127
     c52:	93 e4       	ldi	r25, 0x43	; 67
     c54:	21 50       	subi	r18, 0x01	; 1
     c56:	80 40       	sbci	r24, 0x00	; 0
     c58:	90 40       	sbci	r25, 0x00	; 0
     c5a:	e1 f7       	brne	.-8      	; 0xc54 <place_container_on_rotating_structure+0x12a>
     c5c:	00 c0       	rjmp	.+0      	; 0xc5e <place_container_on_rotating_structure+0x134>
     c5e:	00 00       	nop
//Function to rotate Servo 1 by a specified angle in the multiples of 1.86 degrees
void servo_1(unsigned char degrees)
{
	float PositionPanServo = 0;
	PositionPanServo = ((float)degrees / 1.86) + 35.0;
	OCR1AH = 0x00;
     c60:	f3 01       	movw	r30, r6
     c62:	10 82       	st	Z, r1
	OCR1AL = (unsigned char) PositionPanServo;
     c64:	81 e5       	ldi	r24, 0x51	; 81
     c66:	f2 01       	movw	r30, r4
     c68:	80 83       	st	Z, r24
     c6a:	ff ef       	ldi	r31, 0xFF	; 255
     c6c:	2f e7       	ldi	r18, 0x7F	; 127
     c6e:	83 e4       	ldi	r24, 0x43	; 67
     c70:	f1 50       	subi	r31, 0x01	; 1
     c72:	20 40       	sbci	r18, 0x00	; 0
     c74:	80 40       	sbci	r24, 0x00	; 0
     c76:	e1 f7       	brne	.-8      	; 0xc70 <place_container_on_rotating_structure+0x146>
     c78:	00 c0       	rjmp	.+0      	; 0xc7a <place_container_on_rotating_structure+0x150>
     c7a:	00 00       	nop
//Function to rotate Servo 2 by a specified angle in the multiples of 1.86 degrees
void servo_2(unsigned char degrees)
{
	float PositionTiltServo = 0;
	PositionTiltServo = ((float)degrees / 1.86) + 35.0;
	OCR1BH = 0x00;
     c7c:	f4 01       	movw	r30, r8
     c7e:	10 82       	st	Z, r1
	OCR1BL = (unsigned char) PositionTiltServo;
     c80:	2d e3       	ldi	r18, 0x3D	; 61
     c82:	f5 01       	movw	r30, r10
     c84:	20 83       	st	Z, r18
     c86:	8f ef       	ldi	r24, 0xFF	; 255
     c88:	9f e7       	ldi	r25, 0x7F	; 127
     c8a:	e3 e4       	ldi	r30, 0x43	; 67
     c8c:	81 50       	subi	r24, 0x01	; 1
     c8e:	90 40       	sbci	r25, 0x00	; 0
     c90:	e0 40       	sbci	r30, 0x00	; 0
     c92:	e1 f7       	brne	.-8      	; 0xc8c <place_container_on_rotating_structure+0x162>
     c94:	00 c0       	rjmp	.+0      	; 0xc96 <place_container_on_rotating_structure+0x16c>
     c96:	00 00       	nop
//Function to rotate Servo 3 by a specified angle in the multiples of 1.86 degrees
void servo_3(unsigned char degrees)
{
	float PositionServo = 0;
	PositionServo = ((float)degrees / 1.86) + 35.0;
	OCR1CH = 0x00;
     c98:	f1 01       	movw	r30, r2
     c9a:	10 82       	st	Z, r1
	OCR1CL = (unsigned char) PositionServo;
     c9c:	2e e4       	ldi	r18, 0x4E	; 78
     c9e:	ec e8       	ldi	r30, 0x8C	; 140
     ca0:	f0 e0       	ldi	r31, 0x00	; 0
     ca2:	20 83       	st	Z, r18
     ca4:	8f ef       	ldi	r24, 0xFF	; 255
     ca6:	9f e7       	ldi	r25, 0x7F	; 127
     ca8:	e3 e4       	ldi	r30, 0x43	; 67
     caa:	81 50       	subi	r24, 0x01	; 1
     cac:	90 40       	sbci	r25, 0x00	; 0
     cae:	e0 40       	sbci	r30, 0x00	; 0
     cb0:	e1 f7       	brne	.-8      	; 0xcaa <place_container_on_rotating_structure+0x180>
     cb2:	00 c0       	rjmp	.+0      	; 0xcb4 <place_container_on_rotating_structure+0x18a>
     cb4:	00 00       	nop
//Function to rotate Servo 2 by a specified angle in the multiples of 1.86 degrees
void servo_2(unsigned char degrees)
{
	float PositionTiltServo = 0;
	PositionTiltServo = ((float)degrees / 1.86) + 35.0;
	OCR1BH = 0x00;
     cb6:	f4 01       	movw	r30, r8
     cb8:	10 82       	st	Z, r1
	OCR1BL = (unsigned char) PositionTiltServo;
     cba:	28 e5       	ldi	r18, 0x58	; 88
     cbc:	f5 01       	movw	r30, r10
     cbe:	20 83       	st	Z, r18
     cc0:	8f ef       	ldi	r24, 0xFF	; 255
     cc2:	9f e7       	ldi	r25, 0x7F	; 127
     cc4:	e3 e4       	ldi	r30, 0x43	; 67
     cc6:	81 50       	subi	r24, 0x01	; 1
     cc8:	90 40       	sbci	r25, 0x00	; 0
     cca:	e0 40       	sbci	r30, 0x00	; 0
     ccc:	e1 f7       	brne	.-8      	; 0xcc6 <place_container_on_rotating_structure+0x19c>
     cce:	00 c0       	rjmp	.+0      	; 0xcd0 <place_container_on_rotating_structure+0x1a6>
     cd0:	00 00       	nop
//Function to rotate Servo 1 by a specified angle in the multiples of 1.86 degrees
void servo_1(unsigned char degrees)
{
	float PositionPanServo = 0;
	PositionPanServo = ((float)degrees / 1.86) + 35.0;
	OCR1AH = 0x00;
     cd2:	f3 01       	movw	r30, r6
     cd4:	10 82       	st	Z, r1
	OCR1AL = (unsigned char) PositionPanServo;
     cd6:	23 e8       	ldi	r18, 0x83	; 131
     cd8:	f2 01       	movw	r30, r4
     cda:	20 83       	st	Z, r18
     cdc:	8f ef       	ldi	r24, 0xFF	; 255
     cde:	9f e7       	ldi	r25, 0x7F	; 127
     ce0:	e3 e4       	ldi	r30, 0x43	; 67
     ce2:	81 50       	subi	r24, 0x01	; 1
     ce4:	90 40       	sbci	r25, 0x00	; 0
     ce6:	e0 40       	sbci	r30, 0x00	; 0
     ce8:	e1 f7       	brne	.-8      	; 0xce2 <place_container_on_rotating_structure+0x1b8>
     cea:	00 c0       	rjmp	.+0      	; 0xcec <place_container_on_rotating_structure+0x1c2>
     cec:	00 00       	nop
//Function to rotate Servo 2 by a specified angle in the multiples of 1.86 degrees
void servo_2(unsigned char degrees)
{
	float PositionTiltServo = 0;
	PositionTiltServo = ((float)degrees / 1.86) + 35.0;
	OCR1BH = 0x00;
     cee:	f4 01       	movw	r30, r8
     cf0:	10 82       	st	Z, r1
	OCR1BL = (unsigned char) PositionTiltServo;
     cf2:	28 e4       	ldi	r18, 0x48	; 72
     cf4:	f5 01       	movw	r30, r10
     cf6:	20 83       	st	Z, r18
     cf8:	8f ef       	ldi	r24, 0xFF	; 255
     cfa:	9f e7       	ldi	r25, 0x7F	; 127
     cfc:	e3 e4       	ldi	r30, 0x43	; 67
     cfe:	81 50       	subi	r24, 0x01	; 1
     d00:	90 40       	sbci	r25, 0x00	; 0
     d02:	e0 40       	sbci	r30, 0x00	; 0
     d04:	e1 f7       	brne	.-8      	; 0xcfe <place_container_on_rotating_structure+0x1d4>
     d06:	00 c0       	rjmp	.+0      	; 0xd08 <place_container_on_rotating_structure+0x1de>
     d08:	00 00       	nop
//Function to rotate Servo 3 by a specified angle in the multiples of 1.86 degrees
void servo_3(unsigned char degrees)
{
	float PositionServo = 0;
	PositionServo = ((float)degrees / 1.86) + 35.0;
	OCR1CH = 0x00;
     d0a:	f1 01       	movw	r30, r2
     d0c:	10 82       	st	Z, r1
	OCR1CL = (unsigned char) PositionServo;
     d0e:	23 e2       	ldi	r18, 0x23	; 35
     d10:	ec e8       	ldi	r30, 0x8C	; 140
     d12:	f0 e0       	ldi	r31, 0x00	; 0
     d14:	20 83       	st	Z, r18
				servo_1(180);//arm rotates to front
				_delay_ms(1500);
				servo_2(70);//arm comes to an angle to drop the object
				_delay_ms(1500);
				servo_3(0);//flap opens and the object is droped
				initialize_servo();
     d16:	0e 94 a9 02 	call	0x552	; 0x552 <initialize_servo>
     d1a:	ea c0       	rjmp	.+468    	; 0xef0 <place_container_on_rotating_structure+0x3c6>
			}
			if(empty_container_position==3)
     d1c:	03 30       	cpi	r16, 0x03	; 3
     d1e:	11 05       	cpc	r17, r1
     d20:	09 f0       	breq	.+2      	; 0xd24 <place_container_on_rotating_structure+0x1fa>
     d22:	71 c0       	rjmp	.+226    	; 0xe06 <place_container_on_rotating_structure+0x2dc>
			{
				send(colour_sequence[i_copy]);
     d24:	f6 01       	movw	r30, r12
     d26:	e0 50       	subi	r30, 0x00	; 0
     d28:	fe 4f       	sbci	r31, 0xFE	; 254
     d2a:	80 81       	ld	r24, Z
logic:sends the signal multiple times since it may be possible zigbee on the other hand might not recieve the signal send from here
Example call:send('A')
*/
void send(unsigned char data_to_be_sent)//function to send data
{
		UDR0=data_to_be_sent;
     d2c:	e6 ec       	ldi	r30, 0xC6	; 198
     d2e:	f0 e0       	ldi	r31, 0x00	; 0
     d30:	80 83       	st	Z, r24
				initialize_servo();
			}
			if(empty_container_position==3)
			{
				send(colour_sequence[i_copy]);
				i_copy--;
     d32:	f1 e0       	ldi	r31, 0x01	; 1
     d34:	cf 1a       	sub	r12, r31
     d36:	d1 08       	sbc	r13, r1
     d38:	2f ef       	ldi	r18, 0xFF	; 255
     d3a:	8f e7       	ldi	r24, 0x7F	; 127
     d3c:	93 e4       	ldi	r25, 0x43	; 67
     d3e:	21 50       	subi	r18, 0x01	; 1
     d40:	80 40       	sbci	r24, 0x00	; 0
     d42:	90 40       	sbci	r25, 0x00	; 0
     d44:	e1 f7       	brne	.-8      	; 0xd3e <place_container_on_rotating_structure+0x214>
     d46:	00 c0       	rjmp	.+0      	; 0xd48 <place_container_on_rotating_structure+0x21e>
     d48:	00 00       	nop
//Function to rotate Servo 1 by a specified angle in the multiples of 1.86 degrees
void servo_1(unsigned char degrees)
{
	float PositionPanServo = 0;
	PositionPanServo = ((float)degrees / 1.86) + 35.0;
	OCR1AH = 0x00;
     d4a:	f3 01       	movw	r30, r6
     d4c:	10 82       	st	Z, r1
	OCR1AL = (unsigned char) PositionPanServo;
     d4e:	80 e4       	ldi	r24, 0x40	; 64
     d50:	f2 01       	movw	r30, r4
     d52:	80 83       	st	Z, r24
     d54:	ff ef       	ldi	r31, 0xFF	; 255
     d56:	2f e7       	ldi	r18, 0x7F	; 127
     d58:	83 e4       	ldi	r24, 0x43	; 67
     d5a:	f1 50       	subi	r31, 0x01	; 1
     d5c:	20 40       	sbci	r18, 0x00	; 0
     d5e:	80 40       	sbci	r24, 0x00	; 0
     d60:	e1 f7       	brne	.-8      	; 0xd5a <place_container_on_rotating_structure+0x230>
     d62:	00 c0       	rjmp	.+0      	; 0xd64 <place_container_on_rotating_structure+0x23a>
     d64:	00 00       	nop
//Function to rotate Servo 2 by a specified angle in the multiples of 1.86 degrees
void servo_2(unsigned char degrees)
{
	float PositionTiltServo = 0;
	PositionTiltServo = ((float)degrees / 1.86) + 35.0;
	OCR1BH = 0x00;
     d66:	f4 01       	movw	r30, r8
     d68:	10 82       	st	Z, r1
	OCR1BL = (unsigned char) PositionTiltServo;
     d6a:	2d e3       	ldi	r18, 0x3D	; 61
     d6c:	f5 01       	movw	r30, r10
     d6e:	20 83       	st	Z, r18
     d70:	8f ef       	ldi	r24, 0xFF	; 255
     d72:	9f e7       	ldi	r25, 0x7F	; 127
     d74:	e3 e4       	ldi	r30, 0x43	; 67
     d76:	81 50       	subi	r24, 0x01	; 1
     d78:	90 40       	sbci	r25, 0x00	; 0
     d7a:	e0 40       	sbci	r30, 0x00	; 0
     d7c:	e1 f7       	brne	.-8      	; 0xd76 <place_container_on_rotating_structure+0x24c>
     d7e:	00 c0       	rjmp	.+0      	; 0xd80 <place_container_on_rotating_structure+0x256>
     d80:	00 00       	nop
//Function to rotate Servo 3 by a specified angle in the multiples of 1.86 degrees
void servo_3(unsigned char degrees)
{
	float PositionServo = 0;
	PositionServo = ((float)degrees / 1.86) + 35.0;
	OCR1CH = 0x00;
     d82:	f1 01       	movw	r30, r2
     d84:	10 82       	st	Z, r1
	OCR1CL = (unsigned char) PositionServo;
     d86:	2e e4       	ldi	r18, 0x4E	; 78
     d88:	ec e8       	ldi	r30, 0x8C	; 140
     d8a:	f0 e0       	ldi	r31, 0x00	; 0
     d8c:	20 83       	st	Z, r18
     d8e:	8f ef       	ldi	r24, 0xFF	; 255
     d90:	9f e7       	ldi	r25, 0x7F	; 127
     d92:	e3 e4       	ldi	r30, 0x43	; 67
     d94:	81 50       	subi	r24, 0x01	; 1
     d96:	90 40       	sbci	r25, 0x00	; 0
     d98:	e0 40       	sbci	r30, 0x00	; 0
     d9a:	e1 f7       	brne	.-8      	; 0xd94 <place_container_on_rotating_structure+0x26a>
     d9c:	00 c0       	rjmp	.+0      	; 0xd9e <place_container_on_rotating_structure+0x274>
     d9e:	00 00       	nop
//Function to rotate Servo 2 by a specified angle in the multiples of 1.86 degrees
void servo_2(unsigned char degrees)
{
	float PositionTiltServo = 0;
	PositionTiltServo = ((float)degrees / 1.86) + 35.0;
	OCR1BH = 0x00;
     da0:	f4 01       	movw	r30, r8
     da2:	10 82       	st	Z, r1
	OCR1BL = (unsigned char) PositionTiltServo;
     da4:	28 e5       	ldi	r18, 0x58	; 88
     da6:	f5 01       	movw	r30, r10
     da8:	20 83       	st	Z, r18
     daa:	8f ef       	ldi	r24, 0xFF	; 255
     dac:	9f e7       	ldi	r25, 0x7F	; 127
     dae:	e3 e4       	ldi	r30, 0x43	; 67
     db0:	81 50       	subi	r24, 0x01	; 1
     db2:	90 40       	sbci	r25, 0x00	; 0
     db4:	e0 40       	sbci	r30, 0x00	; 0
     db6:	e1 f7       	brne	.-8      	; 0xdb0 <place_container_on_rotating_structure+0x286>
     db8:	00 c0       	rjmp	.+0      	; 0xdba <place_container_on_rotating_structure+0x290>
     dba:	00 00       	nop
//Function to rotate Servo 1 by a specified angle in the multiples of 1.86 degrees
void servo_1(unsigned char degrees)
{
	float PositionPanServo = 0;
	PositionPanServo = ((float)degrees / 1.86) + 35.0;
	OCR1AH = 0x00;
     dbc:	f3 01       	movw	r30, r6
     dbe:	10 82       	st	Z, r1
	OCR1AL = (unsigned char) PositionPanServo;
     dc0:	23 e8       	ldi	r18, 0x83	; 131
     dc2:	f2 01       	movw	r30, r4
     dc4:	20 83       	st	Z, r18
     dc6:	8f ef       	ldi	r24, 0xFF	; 255
     dc8:	9f e7       	ldi	r25, 0x7F	; 127
     dca:	e3 e4       	ldi	r30, 0x43	; 67
     dcc:	81 50       	subi	r24, 0x01	; 1
     dce:	90 40       	sbci	r25, 0x00	; 0
     dd0:	e0 40       	sbci	r30, 0x00	; 0
     dd2:	e1 f7       	brne	.-8      	; 0xdcc <place_container_on_rotating_structure+0x2a2>
     dd4:	00 c0       	rjmp	.+0      	; 0xdd6 <place_container_on_rotating_structure+0x2ac>
     dd6:	00 00       	nop
//Function to rotate Servo 2 by a specified angle in the multiples of 1.86 degrees
void servo_2(unsigned char degrees)
{
	float PositionTiltServo = 0;
	PositionTiltServo = ((float)degrees / 1.86) + 35.0;
	OCR1BH = 0x00;
     dd8:	f4 01       	movw	r30, r8
     dda:	10 82       	st	Z, r1
	OCR1BL = (unsigned char) PositionTiltServo;
     ddc:	28 e4       	ldi	r18, 0x48	; 72
     dde:	f5 01       	movw	r30, r10
     de0:	20 83       	st	Z, r18
     de2:	8f ef       	ldi	r24, 0xFF	; 255
     de4:	9f e7       	ldi	r25, 0x7F	; 127
     de6:	e3 e4       	ldi	r30, 0x43	; 67
     de8:	81 50       	subi	r24, 0x01	; 1
     dea:	90 40       	sbci	r25, 0x00	; 0
     dec:	e0 40       	sbci	r30, 0x00	; 0
     dee:	e1 f7       	brne	.-8      	; 0xde8 <place_container_on_rotating_structure+0x2be>
     df0:	00 c0       	rjmp	.+0      	; 0xdf2 <place_container_on_rotating_structure+0x2c8>
     df2:	00 00       	nop
//Function to rotate Servo 3 by a specified angle in the multiples of 1.86 degrees
void servo_3(unsigned char degrees)
{
	float PositionServo = 0;
	PositionServo = ((float)degrees / 1.86) + 35.0;
	OCR1CH = 0x00;
     df4:	f1 01       	movw	r30, r2
     df6:	10 82       	st	Z, r1
	OCR1CL = (unsigned char) PositionServo;
     df8:	23 e2       	ldi	r18, 0x23	; 35
     dfa:	ec e8       	ldi	r30, 0x8C	; 140
     dfc:	f0 e0       	ldi	r31, 0x00	; 0
     dfe:	20 83       	st	Z, r18
				servo_1(180);//arm rotates to front
				_delay_ms(1500);
				servo_2(70);//arm comes to an angle to drop the object
				_delay_ms(1500);
				servo_3(0);//flap opens and the object is droped
				initialize_servo();
     e00:	0e 94 a9 02 	call	0x552	; 0x552 <initialize_servo>
     e04:	e9 c0       	rjmp	.+466    	; 0xfd8 <place_container_on_rotating_structure+0x4ae>
				
			}
			if(empty_container_position==2)
     e06:	02 30       	cpi	r16, 0x02	; 2
     e08:	11 05       	cpc	r17, r1
     e0a:	09 f0       	breq	.+2      	; 0xe0e <place_container_on_rotating_structure+0x2e4>
     e0c:	71 c0       	rjmp	.+226    	; 0xef0 <place_container_on_rotating_structure+0x3c6>
			{
				send(colour_sequence[i_copy]);
     e0e:	f6 01       	movw	r30, r12
     e10:	e0 50       	subi	r30, 0x00	; 0
     e12:	fe 4f       	sbci	r31, 0xFE	; 254
     e14:	80 81       	ld	r24, Z
logic:sends the signal multiple times since it may be possible zigbee on the other hand might not recieve the signal send from here
Example call:send('A')
*/
void send(unsigned char data_to_be_sent)//function to send data
{
		UDR0=data_to_be_sent;
     e16:	e6 ec       	ldi	r30, 0xC6	; 198
     e18:	f0 e0       	ldi	r31, 0x00	; 0
     e1a:	80 83       	st	Z, r24
				
			}
			if(empty_container_position==2)
			{
				send(colour_sequence[i_copy]);
				i_copy--;
     e1c:	f1 e0       	ldi	r31, 0x01	; 1
     e1e:	cf 1a       	sub	r12, r31
     e20:	d1 08       	sbc	r13, r1
     e22:	2f ef       	ldi	r18, 0xFF	; 255
     e24:	8f e7       	ldi	r24, 0x7F	; 127
     e26:	93 e4       	ldi	r25, 0x43	; 67
     e28:	21 50       	subi	r18, 0x01	; 1
     e2a:	80 40       	sbci	r24, 0x00	; 0
     e2c:	90 40       	sbci	r25, 0x00	; 0
     e2e:	e1 f7       	brne	.-8      	; 0xe28 <place_container_on_rotating_structure+0x2fe>
     e30:	00 c0       	rjmp	.+0      	; 0xe32 <place_container_on_rotating_structure+0x308>
     e32:	00 00       	nop
//Function to rotate Servo 1 by a specified angle in the multiples of 1.86 degrees
void servo_1(unsigned char degrees)
{
	float PositionPanServo = 0;
	PositionPanServo = ((float)degrees / 1.86) + 35.0;
	OCR1AH = 0x00;
     e34:	f3 01       	movw	r30, r6
     e36:	10 82       	st	Z, r1
	OCR1AL = (unsigned char) PositionPanServo;
     e38:	8f e2       	ldi	r24, 0x2F	; 47
     e3a:	f2 01       	movw	r30, r4
     e3c:	80 83       	st	Z, r24
     e3e:	ff ef       	ldi	r31, 0xFF	; 255
     e40:	2f e7       	ldi	r18, 0x7F	; 127
     e42:	83 e4       	ldi	r24, 0x43	; 67
     e44:	f1 50       	subi	r31, 0x01	; 1
     e46:	20 40       	sbci	r18, 0x00	; 0
     e48:	80 40       	sbci	r24, 0x00	; 0
     e4a:	e1 f7       	brne	.-8      	; 0xe44 <place_container_on_rotating_structure+0x31a>
     e4c:	00 c0       	rjmp	.+0      	; 0xe4e <place_container_on_rotating_structure+0x324>
     e4e:	00 00       	nop
//Function to rotate Servo 2 by a specified angle in the multiples of 1.86 degrees
void servo_2(unsigned char degrees)
{
	float PositionTiltServo = 0;
	PositionTiltServo = ((float)degrees / 1.86) + 35.0;
	OCR1BH = 0x00;
     e50:	f4 01       	movw	r30, r8
     e52:	10 82       	st	Z, r1
	OCR1BL = (unsigned char) PositionTiltServo;
     e54:	2d e3       	ldi	r18, 0x3D	; 61
     e56:	f5 01       	movw	r30, r10
     e58:	20 83       	st	Z, r18
     e5a:	8f ef       	ldi	r24, 0xFF	; 255
     e5c:	9f e7       	ldi	r25, 0x7F	; 127
     e5e:	e3 e4       	ldi	r30, 0x43	; 67
     e60:	81 50       	subi	r24, 0x01	; 1
     e62:	90 40       	sbci	r25, 0x00	; 0
     e64:	e0 40       	sbci	r30, 0x00	; 0
     e66:	e1 f7       	brne	.-8      	; 0xe60 <place_container_on_rotating_structure+0x336>
     e68:	00 c0       	rjmp	.+0      	; 0xe6a <place_container_on_rotating_structure+0x340>
     e6a:	00 00       	nop
//Function to rotate Servo 3 by a specified angle in the multiples of 1.86 degrees
void servo_3(unsigned char degrees)
{
	float PositionServo = 0;
	PositionServo = ((float)degrees / 1.86) + 35.0;
	OCR1CH = 0x00;
     e6c:	f1 01       	movw	r30, r2
     e6e:	10 82       	st	Z, r1
	OCR1CL = (unsigned char) PositionServo;
     e70:	2e e4       	ldi	r18, 0x4E	; 78
     e72:	ec e8       	ldi	r30, 0x8C	; 140
     e74:	f0 e0       	ldi	r31, 0x00	; 0
     e76:	20 83       	st	Z, r18
     e78:	8f ef       	ldi	r24, 0xFF	; 255
     e7a:	9f e7       	ldi	r25, 0x7F	; 127
     e7c:	e3 e4       	ldi	r30, 0x43	; 67
     e7e:	81 50       	subi	r24, 0x01	; 1
     e80:	90 40       	sbci	r25, 0x00	; 0
     e82:	e0 40       	sbci	r30, 0x00	; 0
     e84:	e1 f7       	brne	.-8      	; 0xe7e <place_container_on_rotating_structure+0x354>
     e86:	00 c0       	rjmp	.+0      	; 0xe88 <place_container_on_rotating_structure+0x35e>
     e88:	00 00       	nop
//Function to rotate Servo 2 by a specified angle in the multiples of 1.86 degrees
void servo_2(unsigned char degrees)
{
	float PositionTiltServo = 0;
	PositionTiltServo = ((float)degrees / 1.86) + 35.0;
	OCR1BH = 0x00;
     e8a:	f4 01       	movw	r30, r8
     e8c:	10 82       	st	Z, r1
	OCR1BL = (unsigned char) PositionTiltServo;
     e8e:	28 e5       	ldi	r18, 0x58	; 88
     e90:	f5 01       	movw	r30, r10
     e92:	20 83       	st	Z, r18
     e94:	8f ef       	ldi	r24, 0xFF	; 255
     e96:	9f e7       	ldi	r25, 0x7F	; 127
     e98:	e3 e4       	ldi	r30, 0x43	; 67
     e9a:	81 50       	subi	r24, 0x01	; 1
     e9c:	90 40       	sbci	r25, 0x00	; 0
     e9e:	e0 40       	sbci	r30, 0x00	; 0
     ea0:	e1 f7       	brne	.-8      	; 0xe9a <place_container_on_rotating_structure+0x370>
     ea2:	00 c0       	rjmp	.+0      	; 0xea4 <place_container_on_rotating_structure+0x37a>
     ea4:	00 00       	nop
//Function to rotate Servo 1 by a specified angle in the multiples of 1.86 degrees
void servo_1(unsigned char degrees)
{
	float PositionPanServo = 0;
	PositionPanServo = ((float)degrees / 1.86) + 35.0;
	OCR1AH = 0x00;
     ea6:	f3 01       	movw	r30, r6
     ea8:	10 82       	st	Z, r1
	OCR1AL = (unsigned char) PositionPanServo;
     eaa:	23 e8       	ldi	r18, 0x83	; 131
     eac:	f2 01       	movw	r30, r4
     eae:	20 83       	st	Z, r18
     eb0:	8f ef       	ldi	r24, 0xFF	; 255
     eb2:	9f e7       	ldi	r25, 0x7F	; 127
     eb4:	e3 e4       	ldi	r30, 0x43	; 67
     eb6:	81 50       	subi	r24, 0x01	; 1
     eb8:	90 40       	sbci	r25, 0x00	; 0
     eba:	e0 40       	sbci	r30, 0x00	; 0
     ebc:	e1 f7       	brne	.-8      	; 0xeb6 <place_container_on_rotating_structure+0x38c>
     ebe:	00 c0       	rjmp	.+0      	; 0xec0 <place_container_on_rotating_structure+0x396>
     ec0:	00 00       	nop
//Function to rotate Servo 2 by a specified angle in the multiples of 1.86 degrees
void servo_2(unsigned char degrees)
{
	float PositionTiltServo = 0;
	PositionTiltServo = ((float)degrees / 1.86) + 35.0;
	OCR1BH = 0x00;
     ec2:	f4 01       	movw	r30, r8
     ec4:	10 82       	st	Z, r1
	OCR1BL = (unsigned char) PositionTiltServo;
     ec6:	28 e4       	ldi	r18, 0x48	; 72
     ec8:	f5 01       	movw	r30, r10
     eca:	20 83       	st	Z, r18
     ecc:	8f ef       	ldi	r24, 0xFF	; 255
     ece:	9f e7       	ldi	r25, 0x7F	; 127
     ed0:	e3 e4       	ldi	r30, 0x43	; 67
     ed2:	81 50       	subi	r24, 0x01	; 1
     ed4:	90 40       	sbci	r25, 0x00	; 0
     ed6:	e0 40       	sbci	r30, 0x00	; 0
     ed8:	e1 f7       	brne	.-8      	; 0xed2 <place_container_on_rotating_structure+0x3a8>
     eda:	00 c0       	rjmp	.+0      	; 0xedc <place_container_on_rotating_structure+0x3b2>
     edc:	00 00       	nop
//Function to rotate Servo 3 by a specified angle in the multiples of 1.86 degrees
void servo_3(unsigned char degrees)
{
	float PositionServo = 0;
	PositionServo = ((float)degrees / 1.86) + 35.0;
	OCR1CH = 0x00;
     ede:	f1 01       	movw	r30, r2
     ee0:	10 82       	st	Z, r1
	OCR1CL = (unsigned char) PositionServo;
     ee2:	23 e2       	ldi	r18, 0x23	; 35
     ee4:	ec e8       	ldi	r30, 0x8C	; 140
     ee6:	f0 e0       	ldi	r31, 0x00	; 0
     ee8:	20 83       	st	Z, r18
				servo_1(180);//arm rotates to front
				_delay_ms(1500);
				servo_2(70);//arm comes to an angle to drop the object
				_delay_ms(1500);
				servo_3(0);//flap opens and the object is droped
				initialize_servo();
     eea:	0e 94 a9 02 	call	0x552	; 0x552 <initialize_servo>
     eee:	74 c0       	rjmp	.+232    	; 0xfd8 <place_container_on_rotating_structure+0x4ae>
			}
			if(empty_container_position==1)
     ef0:	21 97       	sbiw	r28, 0x01	; 1
     ef2:	09 f0       	breq	.+2      	; 0xef6 <place_container_on_rotating_structure+0x3cc>
     ef4:	71 c0       	rjmp	.+226    	; 0xfd8 <place_container_on_rotating_structure+0x4ae>
			{
				send(colour_sequence[i_copy]);
     ef6:	f6 01       	movw	r30, r12
     ef8:	e0 50       	subi	r30, 0x00	; 0
     efa:	fe 4f       	sbci	r31, 0xFE	; 254
     efc:	80 81       	ld	r24, Z
logic:sends the signal multiple times since it may be possible zigbee on the other hand might not recieve the signal send from here
Example call:send('A')
*/
void send(unsigned char data_to_be_sent)//function to send data
{
		UDR0=data_to_be_sent;
     efe:	e6 ec       	ldi	r30, 0xC6	; 198
     f00:	f0 e0       	ldi	r31, 0x00	; 0
     f02:	80 83       	st	Z, r24
				initialize_servo();
			}
			if(empty_container_position==1)
			{
				send(colour_sequence[i_copy]);
				i_copy--;
     f04:	f1 e0       	ldi	r31, 0x01	; 1
     f06:	cf 1a       	sub	r12, r31
     f08:	d1 08       	sbc	r13, r1
     f0a:	2f ef       	ldi	r18, 0xFF	; 255
     f0c:	8f e7       	ldi	r24, 0x7F	; 127
     f0e:	93 e4       	ldi	r25, 0x43	; 67
     f10:	21 50       	subi	r18, 0x01	; 1
     f12:	80 40       	sbci	r24, 0x00	; 0
     f14:	90 40       	sbci	r25, 0x00	; 0
     f16:	e1 f7       	brne	.-8      	; 0xf10 <place_container_on_rotating_structure+0x3e6>
     f18:	00 c0       	rjmp	.+0      	; 0xf1a <place_container_on_rotating_structure+0x3f0>
     f1a:	00 00       	nop
//Function to rotate Servo 1 by a specified angle in the multiples of 1.86 degrees
void servo_1(unsigned char degrees)
{
	float PositionPanServo = 0;
	PositionPanServo = ((float)degrees / 1.86) + 35.0;
	OCR1AH = 0x00;
     f1c:	f3 01       	movw	r30, r6
     f1e:	10 82       	st	Z, r1
	OCR1AL = (unsigned char) PositionPanServo;
     f20:	23 e2       	ldi	r18, 0x23	; 35
     f22:	f2 01       	movw	r30, r4
     f24:	20 83       	st	Z, r18
     f26:	8f ef       	ldi	r24, 0xFF	; 255
     f28:	9f e7       	ldi	r25, 0x7F	; 127
     f2a:	e3 e4       	ldi	r30, 0x43	; 67
     f2c:	81 50       	subi	r24, 0x01	; 1
     f2e:	90 40       	sbci	r25, 0x00	; 0
     f30:	e0 40       	sbci	r30, 0x00	; 0
     f32:	e1 f7       	brne	.-8      	; 0xf2c <place_container_on_rotating_structure+0x402>
     f34:	00 c0       	rjmp	.+0      	; 0xf36 <place_container_on_rotating_structure+0x40c>
     f36:	00 00       	nop
//Function to rotate Servo 2 by a specified angle in the multiples of 1.86 degrees
void servo_2(unsigned char degrees)
{
	float PositionTiltServo = 0;
	PositionTiltServo = ((float)degrees / 1.86) + 35.0;
	OCR1BH = 0x00;
     f38:	f4 01       	movw	r30, r8
     f3a:	10 82       	st	Z, r1
	OCR1BL = (unsigned char) PositionTiltServo;
     f3c:	2d e3       	ldi	r18, 0x3D	; 61
     f3e:	f5 01       	movw	r30, r10
     f40:	20 83       	st	Z, r18
     f42:	8f ef       	ldi	r24, 0xFF	; 255
     f44:	9f e7       	ldi	r25, 0x7F	; 127
     f46:	e3 e4       	ldi	r30, 0x43	; 67
     f48:	81 50       	subi	r24, 0x01	; 1
     f4a:	90 40       	sbci	r25, 0x00	; 0
     f4c:	e0 40       	sbci	r30, 0x00	; 0
     f4e:	e1 f7       	brne	.-8      	; 0xf48 <place_container_on_rotating_structure+0x41e>
     f50:	00 c0       	rjmp	.+0      	; 0xf52 <place_container_on_rotating_structure+0x428>
     f52:	00 00       	nop
//Function to rotate Servo 3 by a specified angle in the multiples of 1.86 degrees
void servo_3(unsigned char degrees)
{
	float PositionServo = 0;
	PositionServo = ((float)degrees / 1.86) + 35.0;
	OCR1CH = 0x00;
     f54:	f1 01       	movw	r30, r2
     f56:	10 82       	st	Z, r1
	OCR1CL = (unsigned char) PositionServo;
     f58:	2e e4       	ldi	r18, 0x4E	; 78
     f5a:	ec e8       	ldi	r30, 0x8C	; 140
     f5c:	f0 e0       	ldi	r31, 0x00	; 0
     f5e:	20 83       	st	Z, r18
     f60:	8f ef       	ldi	r24, 0xFF	; 255
     f62:	9f e7       	ldi	r25, 0x7F	; 127
     f64:	e3 e4       	ldi	r30, 0x43	; 67
     f66:	81 50       	subi	r24, 0x01	; 1
     f68:	90 40       	sbci	r25, 0x00	; 0
     f6a:	e0 40       	sbci	r30, 0x00	; 0
     f6c:	e1 f7       	brne	.-8      	; 0xf66 <place_container_on_rotating_structure+0x43c>
     f6e:	00 c0       	rjmp	.+0      	; 0xf70 <place_container_on_rotating_structure+0x446>
     f70:	00 00       	nop
//Function to rotate Servo 2 by a specified angle in the multiples of 1.86 degrees
void servo_2(unsigned char degrees)
{
	float PositionTiltServo = 0;
	PositionTiltServo = ((float)degrees / 1.86) + 35.0;
	OCR1BH = 0x00;
     f72:	f4 01       	movw	r30, r8
     f74:	10 82       	st	Z, r1
	OCR1BL = (unsigned char) PositionTiltServo;
     f76:	28 e5       	ldi	r18, 0x58	; 88
     f78:	f5 01       	movw	r30, r10
     f7a:	20 83       	st	Z, r18
     f7c:	8f ef       	ldi	r24, 0xFF	; 255
     f7e:	9f e7       	ldi	r25, 0x7F	; 127
     f80:	e3 e4       	ldi	r30, 0x43	; 67
     f82:	81 50       	subi	r24, 0x01	; 1
     f84:	90 40       	sbci	r25, 0x00	; 0
     f86:	e0 40       	sbci	r30, 0x00	; 0
     f88:	e1 f7       	brne	.-8      	; 0xf82 <place_container_on_rotating_structure+0x458>
     f8a:	00 c0       	rjmp	.+0      	; 0xf8c <place_container_on_rotating_structure+0x462>
     f8c:	00 00       	nop
//Function to rotate Servo 1 by a specified angle in the multiples of 1.86 degrees
void servo_1(unsigned char degrees)
{
	float PositionPanServo = 0;
	PositionPanServo = ((float)degrees / 1.86) + 35.0;
	OCR1AH = 0x00;
     f8e:	f3 01       	movw	r30, r6
     f90:	10 82       	st	Z, r1
	OCR1AL = (unsigned char) PositionPanServo;
     f92:	23 e8       	ldi	r18, 0x83	; 131
     f94:	f2 01       	movw	r30, r4
     f96:	20 83       	st	Z, r18
     f98:	8f ef       	ldi	r24, 0xFF	; 255
     f9a:	9f e7       	ldi	r25, 0x7F	; 127
     f9c:	e3 e4       	ldi	r30, 0x43	; 67
     f9e:	81 50       	subi	r24, 0x01	; 1
     fa0:	90 40       	sbci	r25, 0x00	; 0
     fa2:	e0 40       	sbci	r30, 0x00	; 0
     fa4:	e1 f7       	brne	.-8      	; 0xf9e <place_container_on_rotating_structure+0x474>
     fa6:	00 c0       	rjmp	.+0      	; 0xfa8 <place_container_on_rotating_structure+0x47e>
     fa8:	00 00       	nop
//Function to rotate Servo 2 by a specified angle in the multiples of 1.86 degrees
void servo_2(unsigned char degrees)
{
	float PositionTiltServo = 0;
	PositionTiltServo = ((float)degrees / 1.86) + 35.0;
	OCR1BH = 0x00;
     faa:	f4 01       	movw	r30, r8
     fac:	10 82       	st	Z, r1
	OCR1BL = (unsigned char) PositionTiltServo;
     fae:	28 e4       	ldi	r18, 0x48	; 72
     fb0:	f5 01       	movw	r30, r10
     fb2:	20 83       	st	Z, r18
     fb4:	8f ef       	ldi	r24, 0xFF	; 255
     fb6:	9f e7       	ldi	r25, 0x7F	; 127
     fb8:	e3 e4       	ldi	r30, 0x43	; 67
     fba:	81 50       	subi	r24, 0x01	; 1
     fbc:	90 40       	sbci	r25, 0x00	; 0
     fbe:	e0 40       	sbci	r30, 0x00	; 0
     fc0:	e1 f7       	brne	.-8      	; 0xfba <place_container_on_rotating_structure+0x490>
     fc2:	00 c0       	rjmp	.+0      	; 0xfc4 <place_container_on_rotating_structure+0x49a>
     fc4:	00 00       	nop
//Function to rotate Servo 3 by a specified angle in the multiples of 1.86 degrees
void servo_3(unsigned char degrees)
{
	float PositionServo = 0;
	PositionServo = ((float)degrees / 1.86) + 35.0;
	OCR1CH = 0x00;
     fc6:	f1 01       	movw	r30, r2
     fc8:	10 82       	st	Z, r1
	OCR1CL = (unsigned char) PositionServo;
     fca:	23 e2       	ldi	r18, 0x23	; 35
     fcc:	ec e8       	ldi	r30, 0x8C	; 140
     fce:	f0 e0       	ldi	r31, 0x00	; 0
     fd0:	20 83       	st	Z, r18
				servo_1(180);//arm rotates to front
				_delay_ms(1500);
				servo_2(70);//arm comes to an angle to drop the object
				_delay_ms(1500);
				servo_3(0);//flap opens and the object is droped
				initialize_servo();
     fd2:	0e 94 a9 02 	call	0x552	; 0x552 <initialize_servo>
     fd6:	27 ce       	rjmp	.-946    	; 0xc26 <place_container_on_rotating_structure+0xfc>
		servo_3(0);//arm drops the object
		_delay_ms(1500);
		
	}
		initialize_servo();
		while(empty_container_position<=4)//empty_container_position will give the last container position where object was placed and then with fall through in switch arm will pickup object from that container as well as all the other previously filled 
     fd8:	85 e0       	ldi	r24, 0x05	; 5
     fda:	e8 16       	cp	r14, r24
     fdc:	f1 04       	cpc	r15, r1
     fde:	0c f4       	brge	.+2      	; 0xfe2 <place_container_on_rotating_structure+0x4b8>
     fe0:	22 ce       	rjmp	.-956    	; 0xc26 <place_container_on_rotating_structure+0xfc>
				initialize_servo();
			}
				empty_container_position++;
		}
	
}
     fe2:	df 91       	pop	r29
     fe4:	cf 91       	pop	r28
     fe6:	1f 91       	pop	r17
     fe8:	0f 91       	pop	r16
     fea:	ff 90       	pop	r15
     fec:	ef 90       	pop	r14
     fee:	df 90       	pop	r13
     ff0:	cf 90       	pop	r12
     ff2:	bf 90       	pop	r11
     ff4:	af 90       	pop	r10
     ff6:	9f 90       	pop	r9
     ff8:	8f 90       	pop	r8
     ffa:	7f 90       	pop	r7
     ffc:	6f 90       	pop	r6
     ffe:	5f 90       	pop	r5
    1000:	4f 90       	pop	r4
    1002:	3f 90       	pop	r3
    1004:	2f 90       	pop	r2
    1006:	08 95       	ret

00001008 <calcdots>:
Output:no. of dots between the two positions(position refers to nodes where the blocks are to placed)
logic:total dots will be equal to difference of two positions + no. of even no. present between them as their is an extra after every integer position
Example call:calcdots(2,6)
*/
int calcdots(int initial_position,int final_position)
{
    1008:	9c 01       	movw	r18, r24
	int dots=0;
	dots=final_position-initial_position-1;
    100a:	cb 01       	movw	r24, r22
    100c:	82 1b       	sub	r24, r18
    100e:	93 0b       	sbc	r25, r19
    1010:	01 97       	sbiw	r24, 0x01	; 1
	while(initial_position<final_position)
    1012:	26 17       	cp	r18, r22
    1014:	37 07       	cpc	r19, r23
    1016:	3c f4       	brge	.+14     	; 0x1026 <calcdots+0x1e>
	{
		if(initial_position % 2==0)
    1018:	20 ff       	sbrs	r18, 0
		{
			dots++;
    101a:	01 96       	adiw	r24, 0x01	; 1
		}
		initial_position++;
    101c:	2f 5f       	subi	r18, 0xFF	; 255
    101e:	3f 4f       	sbci	r19, 0xFF	; 255
*/
int calcdots(int initial_position,int final_position)
{
	int dots=0;
	dots=final_position-initial_position-1;
	while(initial_position<final_position)
    1020:	62 17       	cp	r22, r18
    1022:	73 07       	cpc	r23, r19
    1024:	c9 f7       	brne	.-14     	; 0x1018 <calcdots+0x10>
			dots++;
		}
		initial_position++;
	}
	return dots;	
}
    1026:	08 95       	ret

00001028 <return_rotating_structure>:
Output:no output
logic:the function will navigate the bot from the place where currently he is standing to the rotating structure
Example call:pickup_and_place
*/
void return_rotating_structure(int current_position)
{
    1028:	ef 92       	push	r14
    102a:	ff 92       	push	r15
    102c:	0f 93       	push	r16
    102e:	1f 93       	push	r17
    1030:	cf 93       	push	r28
    1032:	8c 01       	movw	r16, r24
	//we will be using three return paths bot will choose the one closest to it.
	total_rounds++;
    1034:	80 91 28 02 	lds	r24, 0x0228	; 0x800228 <total_rounds>
    1038:	90 91 29 02 	lds	r25, 0x0229	; 0x800229 <total_rounds+0x1>
    103c:	01 96       	adiw	r24, 0x01	; 1
    103e:	90 93 29 02 	sts	0x0229, r25	; 0x800229 <total_rounds+0x1>
    1042:	80 93 28 02 	sts	0x0228, r24	; 0x800228 <total_rounds>
	if(current_position<=4)
    1046:	05 30       	cpi	r16, 0x05	; 5
    1048:	11 05       	cpc	r17, r1
    104a:	ec f4       	brge	.+58     	; 0x1086 <return_rotating_structure+0x5e>
logic:sends the signal multiple times since it may be possible zigbee on the other hand might not recieve the signal send from here
Example call:send('A')
*/
void send(unsigned char data_to_be_sent)//function to send data
{
		UDR0=data_to_be_sent;
    104c:	81 e3       	ldi	r24, 0x31	; 49
    104e:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
	total_rounds++;
	if(current_position<=4)
	{
		//this return path is the one you can find nearest to object position 1
		send('1');//send message that we are coming from this path
		position_while_placing_containers_in_rotating_structure=1;
    1052:	81 e0       	ldi	r24, 0x01	; 1
    1054:	90 e0       	ldi	r25, 0x00	; 0
    1056:	90 93 25 02 	sts	0x0225, r25	; 0x800225 <position_while_placing_containers_in_rotating_structure+0x1>
    105a:	80 93 24 02 	sts	0x0224, r24	; 0x800224 <position_while_placing_containers_in_rotating_structure>
		rotate_anticlockwise(1);
    105e:	0e 94 28 05 	call	0xa50	; 0xa50 <rotate_anticlockwise>
		moveforward(calcdots(1,current_position)+1);
    1062:	b8 01       	movw	r22, r16
    1064:	81 e0       	ldi	r24, 0x01	; 1
    1066:	90 e0       	ldi	r25, 0x00	; 0
    1068:	0e 94 04 08 	call	0x1008	; 0x1008 <calcdots>
    106c:	01 96       	adiw	r24, 0x01	; 1
    106e:	0e 94 41 04 	call	0x882	; 0x882 <moveforward>
		rotate_anticlockwise(1);
    1072:	81 e0       	ldi	r24, 0x01	; 1
    1074:	90 e0       	ldi	r25, 0x00	; 0
    1076:	0e 94 28 05 	call	0xa50	; 0xa50 <rotate_anticlockwise>
				position_while_placing_containers_in_rotating_structure=2;
				rotate_clockwise(1);
				moveforward(calcdots(current_position,12)+1);
				rotate_clockwise(1);
	}
	while(sharp_ir3<0x80)//robot will move forward till a required nearness is not maintained from the robot
    107a:	80 91 12 02 	lds	r24, 0x0212	; 0x800212 <__data_end>
    107e:	88 23       	and	r24, r24
    1080:	0c f0       	brlt	.+2      	; 0x1084 <return_rotating_structure+0x5c>
    1082:	4d c0       	rjmp	.+154    	; 0x111e <return_rotating_structure+0xf6>
    1084:	61 c0       	rjmp	.+194    	; 0x1148 <return_rotating_structure+0x120>
		position_while_placing_containers_in_rotating_structure=1;
		rotate_anticlockwise(1);
		moveforward(calcdots(1,current_position)+1);
		rotate_anticlockwise(1);
	}
	else if(current_position<=8)
    1086:	09 30       	cpi	r16, 0x09	; 9
    1088:	11 05       	cpc	r17, r1
    108a:	7c f5       	brge	.+94     	; 0x10ea <return_rotating_structure+0xc2>
	{
		//this return path is the one you can find nearest to starting position
		//since the rotating structure is initially at this position only so no need to send message 
		position_while_placing_containers_in_rotating_structure=2;
    108c:	82 e0       	ldi	r24, 0x02	; 2
    108e:	90 e0       	ldi	r25, 0x00	; 0
    1090:	90 93 25 02 	sts	0x0225, r25	; 0x800225 <position_while_placing_containers_in_rotating_structure+0x1>
    1094:	80 93 24 02 	sts	0x0224, r24	; 0x800224 <position_while_placing_containers_in_rotating_structure>
		if(current_position<7)
    1098:	07 30       	cpi	r16, 0x07	; 7
    109a:	11 05       	cpc	r17, r1
    109c:	8c f4       	brge	.+34     	; 0x10c0 <return_rotating_structure+0x98>
		{
			rotate_clockwise(1);
    109e:	81 e0       	ldi	r24, 0x01	; 1
    10a0:	90 e0       	ldi	r25, 0x00	; 0
    10a2:	0e 94 c0 04 	call	0x980	; 0x980 <rotate_clockwise>
			moveforward(calcdots(current_position,7)-1);
    10a6:	67 e0       	ldi	r22, 0x07	; 7
    10a8:	70 e0       	ldi	r23, 0x00	; 0
    10aa:	c8 01       	movw	r24, r16
    10ac:	0e 94 04 08 	call	0x1008	; 0x1008 <calcdots>
    10b0:	01 97       	sbiw	r24, 0x01	; 1
    10b2:	0e 94 41 04 	call	0x882	; 0x882 <moveforward>
			rotate_clockwise(1);
    10b6:	81 e0       	ldi	r24, 0x01	; 1
    10b8:	90 e0       	ldi	r25, 0x00	; 0
    10ba:	0e 94 c0 04 	call	0x980	; 0x980 <rotate_clockwise>
    10be:	10 c0       	rjmp	.+32     	; 0x10e0 <return_rotating_structure+0xb8>
		}
		else
		{
			rotate_anticlockwise(1);
    10c0:	81 e0       	ldi	r24, 0x01	; 1
    10c2:	90 e0       	ldi	r25, 0x00	; 0
    10c4:	0e 94 28 05 	call	0xa50	; 0xa50 <rotate_anticlockwise>
			moveforward(calcdots(6,current_position)-1);
    10c8:	b8 01       	movw	r22, r16
    10ca:	86 e0       	ldi	r24, 0x06	; 6
    10cc:	90 e0       	ldi	r25, 0x00	; 0
    10ce:	0e 94 04 08 	call	0x1008	; 0x1008 <calcdots>
    10d2:	01 97       	sbiw	r24, 0x01	; 1
    10d4:	0e 94 41 04 	call	0x882	; 0x882 <moveforward>
			rotate_anticlockwise(1);
    10d8:	81 e0       	ldi	r24, 0x01	; 1
    10da:	90 e0       	ldi	r25, 0x00	; 0
    10dc:	0e 94 28 05 	call	0xa50	; 0xa50 <rotate_anticlockwise>
		}
		moveforward(2);
    10e0:	82 e0       	ldi	r24, 0x02	; 2
    10e2:	90 e0       	ldi	r25, 0x00	; 0
    10e4:	0e 94 41 04 	call	0x882	; 0x882 <moveforward>
    10e8:	c8 cf       	rjmp	.-112    	; 0x107a <return_rotating_structure+0x52>
logic:sends the signal multiple times since it may be possible zigbee on the other hand might not recieve the signal send from here
Example call:send('A')
*/
void send(unsigned char data_to_be_sent)//function to send data
{
		UDR0=data_to_be_sent;
    10ea:	83 e3       	ldi	r24, 0x33	; 51
    10ec:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
	}
	else
	{
				//this return path is the one you can find nearest to object position 3
				send('3');//send message that we are coming from this path
				position_while_placing_containers_in_rotating_structure=2;
    10f0:	82 e0       	ldi	r24, 0x02	; 2
    10f2:	90 e0       	ldi	r25, 0x00	; 0
    10f4:	90 93 25 02 	sts	0x0225, r25	; 0x800225 <position_while_placing_containers_in_rotating_structure+0x1>
    10f8:	80 93 24 02 	sts	0x0224, r24	; 0x800224 <position_while_placing_containers_in_rotating_structure>
				rotate_clockwise(1);
    10fc:	81 e0       	ldi	r24, 0x01	; 1
    10fe:	90 e0       	ldi	r25, 0x00	; 0
    1100:	0e 94 c0 04 	call	0x980	; 0x980 <rotate_clockwise>
				moveforward(calcdots(current_position,12)+1);
    1104:	6c e0       	ldi	r22, 0x0C	; 12
    1106:	70 e0       	ldi	r23, 0x00	; 0
    1108:	c8 01       	movw	r24, r16
    110a:	0e 94 04 08 	call	0x1008	; 0x1008 <calcdots>
    110e:	01 96       	adiw	r24, 0x01	; 1
    1110:	0e 94 41 04 	call	0x882	; 0x882 <moveforward>
				rotate_clockwise(1);
    1114:	81 e0       	ldi	r24, 0x01	; 1
    1116:	90 e0       	ldi	r25, 0x00	; 0
    1118:	0e 94 c0 04 	call	0x980	; 0x980 <rotate_clockwise>
    111c:	ae cf       	rjmp	.-164    	; 0x107a <return_rotating_structure+0x52>
}


void velocity (unsigned char left_motor, unsigned char right_motor)
{
	OCR5AL = (unsigned char)left_motor;
    111e:	0f 2e       	mov	r0, r31
    1120:	f8 e2       	ldi	r31, 0x28	; 40
    1122:	ef 2e       	mov	r14, r31
    1124:	ff 24       	eor	r15, r15
    1126:	f3 94       	inc	r15
    1128:	f0 2d       	mov	r31, r0
    112a:	cc ed       	ldi	r28, 0xDC	; 220
	OCR5BL = (unsigned char)right_motor;
    112c:	0a e2       	ldi	r16, 0x2A	; 42
    112e:	11 e0       	ldi	r17, 0x01	; 1
				moveforward(calcdots(current_position,12)+1);
				rotate_clockwise(1);
	}
	while(sharp_ir3<0x80)//robot will move forward till a required nearness is not maintained from the robot
	{
		sense();
    1130:	0e 94 2c 04 	call	0x858	; 0x858 <sense>
		forward();
    1134:	0e 94 4d 02 	call	0x49a	; 0x49a <forward>
}


void velocity (unsigned char left_motor, unsigned char right_motor)
{
	OCR5AL = (unsigned char)left_motor;
    1138:	f7 01       	movw	r30, r14
    113a:	c0 83       	st	Z, r28
	OCR5BL = (unsigned char)right_motor;
    113c:	f8 01       	movw	r30, r16
    113e:	c0 83       	st	Z, r28
				position_while_placing_containers_in_rotating_structure=2;
				rotate_clockwise(1);
				moveforward(calcdots(current_position,12)+1);
				rotate_clockwise(1);
	}
	while(sharp_ir3<0x80)//robot will move forward till a required nearness is not maintained from the robot
    1140:	80 91 12 02 	lds	r24, 0x0212	; 0x800212 <__data_end>
    1144:	88 23       	and	r24, r24
    1146:	a4 f7       	brge	.-24     	; 0x1130 <return_rotating_structure+0x108>
	{
		sense();
		forward();
		velocity(220,220);
	}
	stop();
    1148:	0e 94 5d 02 	call	0x4ba	; 0x4ba <stop>
    114c:	ff ef       	ldi	r31, 0xFF	; 255
    114e:	2f e7       	ldi	r18, 0x7F	; 127
    1150:	86 e1       	ldi	r24, 0x16	; 22
    1152:	f1 50       	subi	r31, 0x01	; 1
    1154:	20 40       	sbci	r18, 0x00	; 0
    1156:	80 40       	sbci	r24, 0x00	; 0
    1158:	e1 f7       	brne	.-8      	; 0x1152 <return_rotating_structure+0x12a>
    115a:	00 c0       	rjmp	.+0      	; 0x115c <return_rotating_structure+0x134>
    115c:	00 00       	nop
	_delay_ms(500);
}
    115e:	cf 91       	pop	r28
    1160:	1f 91       	pop	r17
    1162:	0f 91       	pop	r16
    1164:	ff 90       	pop	r15
    1166:	ef 90       	pop	r14
    1168:	08 95       	ret

0000116a <start>:
Output:no output
logic:navigates the robot from start position to the next object position or form the previous object position to the next object position
Example start
*/
void start()
{
    116a:	df 92       	push	r13
    116c:	ef 92       	push	r14
    116e:	ff 92       	push	r15
    1170:	0f 93       	push	r16
    1172:	1f 93       	push	r17
    1174:	cf 93       	push	r28
    1176:	df 93       	push	r29
	while(i<object_sequence_length && empty_current_container!=-1)
    1178:	80 91 20 02 	lds	r24, 0x0220	; 0x800220 <i>
    117c:	90 91 21 02 	lds	r25, 0x0221	; 0x800221 <i+0x1>
    1180:	86 30       	cpi	r24, 0x06	; 6
    1182:	91 05       	cpc	r25, r1
    1184:	0c f0       	brlt	.+2      	; 0x1188 <start+0x1e>
    1186:	68 c1       	rjmp	.+720    	; 0x1458 <start+0x2ee>
    1188:	20 91 22 02 	lds	r18, 0x0222	; 0x800222 <empty_current_container>
    118c:	30 91 23 02 	lds	r19, 0x0223	; 0x800223 <empty_current_container+0x1>
    1190:	2f 3f       	cpi	r18, 0xFF	; 255
    1192:	3f 4f       	sbci	r19, 0xFF	; 255
    1194:	09 f4       	brne	.+2      	; 0x1198 <start+0x2e>
    1196:	60 c1       	rjmp	.+704    	; 0x1458 <start+0x2ee>
	{
		if(flag_for_starting_position==0)//flag_for_starting_position==0 signifies robot is at starting position else the robot will be at previous object position
		{
			current_object=object_sequence[i];//it will be used while rotation at the edge when the robot will move from starting position to the outer square and make a turn
			flag_for_starting_position=1;//specifies now object will be found at its previous object location
    1198:	c1 e0       	ldi	r28, 0x01	; 1
    119a:	d0 e0       	ldi	r29, 0x00	; 0
//Function to rotate Servo 2 by a specified angle in the multiples of 1.86 degrees
void servo_2(unsigned char degrees)
{
	float PositionTiltServo = 0;
	PositionTiltServo = ((float)degrees / 1.86) + 35.0;
	OCR1BH = 0x00;
    119c:	0f 2e       	mov	r0, r31
    119e:	fb e8       	ldi	r31, 0x8B	; 139
    11a0:	ef 2e       	mov	r14, r31
    11a2:	f1 2c       	mov	r15, r1
    11a4:	f0 2d       	mov	r31, r0
	OCR1BL = (unsigned char) PositionTiltServo;
    11a6:	0a e8       	ldi	r16, 0x8A	; 138
    11a8:	10 e0       	ldi	r17, 0x00	; 0
    11aa:	0f 2e       	mov	r0, r31
    11ac:	f6 e2       	ldi	r31, 0x26	; 38
    11ae:	df 2e       	mov	r13, r31
    11b0:	f0 2d       	mov	r31, r0
*/
void start()
{
	while(i<object_sequence_length && empty_current_container!=-1)
	{
		if(flag_for_starting_position==0)//flag_for_starting_position==0 signifies robot is at starting position else the robot will be at previous object position
    11b2:	20 91 1e 02 	lds	r18, 0x021E	; 0x80021e <flag_for_starting_position>
    11b6:	30 91 1f 02 	lds	r19, 0x021F	; 0x80021f <flag_for_starting_position+0x1>
    11ba:	23 2b       	or	r18, r19
    11bc:	09 f0       	breq	.+2      	; 0x11c0 <start+0x56>
    11be:	70 c0       	rjmp	.+224    	; 0x12a0 <start+0x136>
		{
			current_object=object_sequence[i];//it will be used while rotation at the edge when the robot will move from starting position to the outer square and make a turn
    11c0:	88 0f       	add	r24, r24
    11c2:	99 1f       	adc	r25, r25
    11c4:	fc 01       	movw	r30, r24
    11c6:	ea 5f       	subi	r30, 0xFA	; 250
    11c8:	fd 4f       	sbci	r31, 0xFD	; 253
    11ca:	20 81       	ld	r18, Z
    11cc:	31 81       	ldd	r19, Z+1	; 0x01
    11ce:	30 93 27 02 	sts	0x0227, r19	; 0x800227 <current_object+0x1>
    11d2:	20 93 26 02 	sts	0x0226, r18	; 0x800226 <current_object>
			flag_for_starting_position=1;//specifies now object will be found at its previous object location
    11d6:	d0 93 1f 02 	sts	0x021F, r29	; 0x80021f <flag_for_starting_position+0x1>
    11da:	c0 93 1e 02 	sts	0x021E, r28	; 0x80021e <flag_for_starting_position>
			//navigate from the starting postion to the (object_sequence[i])th position
			rotate_clockwise(object_sequence[i]/2+1);//rotate  to the line shortest for its object to reach from starting position
    11de:	c9 01       	movw	r24, r18
    11e0:	99 23       	and	r25, r25
    11e2:	0c f4       	brge	.+2      	; 0x11e6 <start+0x7c>
    11e4:	01 96       	adiw	r24, 0x01	; 1
    11e6:	95 95       	asr	r25
    11e8:	87 95       	ror	r24
    11ea:	01 96       	adiw	r24, 0x01	; 1
    11ec:	0e 94 c0 04 	call	0x980	; 0x980 <rotate_clockwise>
			if(object_sequence[i]==1 || object_sequence[i]==12)//since the lines for 1 and 12 from starting position contain a extra dot so given two dot skip statement
    11f0:	e0 91 20 02 	lds	r30, 0x0220	; 0x800220 <i>
    11f4:	f0 91 21 02 	lds	r31, 0x0221	; 0x800221 <i+0x1>
    11f8:	ee 0f       	add	r30, r30
    11fa:	ff 1f       	adc	r31, r31
    11fc:	ea 5f       	subi	r30, 0xFA	; 250
    11fe:	fd 4f       	sbci	r31, 0xFD	; 253
    1200:	80 81       	ld	r24, Z
    1202:	91 81       	ldd	r25, Z+1	; 0x01
    1204:	81 30       	cpi	r24, 0x01	; 1
    1206:	91 05       	cpc	r25, r1
    1208:	11 f0       	breq	.+4      	; 0x120e <start+0xa4>
    120a:	0c 97       	sbiw	r24, 0x0c	; 12
    120c:	29 f4       	brne	.+10     	; 0x1218 <start+0xae>
			{
				moveforward(2);
    120e:	82 e0       	ldi	r24, 0x02	; 2
    1210:	90 e0       	ldi	r25, 0x00	; 0
    1212:	0e 94 41 04 	call	0x882	; 0x882 <moveforward>
    1216:	03 c0       	rjmp	.+6      	; 0x121e <start+0xb4>
			}
			else
			{
				moveforward(1);
    1218:	ce 01       	movw	r24, r28
    121a:	0e 94 41 04 	call	0x882	; 0x882 <moveforward>
			}
			if(object_sequence[i]%2==0)//if the object is at even position the robot will take a turn in anticlockwise direction else in clockwise direction 
    121e:	e0 91 20 02 	lds	r30, 0x0220	; 0x800220 <i>
    1222:	f0 91 21 02 	lds	r31, 0x0221	; 0x800221 <i+0x1>
    1226:	ee 0f       	add	r30, r30
    1228:	ff 1f       	adc	r31, r31
    122a:	ea 5f       	subi	r30, 0xFA	; 250
    122c:	fd 4f       	sbci	r31, 0xFD	; 253
    122e:	80 81       	ld	r24, Z
    1230:	80 fd       	sbrc	r24, 0
    1232:	04 c0       	rjmp	.+8      	; 0x123c <start+0xd2>
			{
				rotate_anticlockwise(1);
    1234:	ce 01       	movw	r24, r28
    1236:	0e 94 28 05 	call	0xa50	; 0xa50 <rotate_anticlockwise>
    123a:	03 c0       	rjmp	.+6      	; 0x1242 <start+0xd8>
			}
			else
			{
				rotate_clockwise(1);
    123c:	ce 01       	movw	r24, r28
    123e:	0e 94 c0 04 	call	0x980	; 0x980 <rotate_clockwise>
			}
			moveforward(0);//robot now will stop at the next dot,at this position the required object is placed 
    1242:	80 e0       	ldi	r24, 0x00	; 0
    1244:	90 e0       	ldi	r25, 0x00	; 0
    1246:	0e 94 41 04 	call	0x882	; 0x882 <moveforward>
			stop();
    124a:	0e 94 5d 02 	call	0x4ba	; 0x4ba <stop>
    124e:	8f ef       	ldi	r24, 0xFF	; 255
    1250:	9f e7       	ldi	r25, 0x7F	; 127
    1252:	e6 e1       	ldi	r30, 0x16	; 22
    1254:	81 50       	subi	r24, 0x01	; 1
    1256:	90 40       	sbci	r25, 0x00	; 0
    1258:	e0 40       	sbci	r30, 0x00	; 0
    125a:	e1 f7       	brne	.-8      	; 0x1254 <start+0xea>
    125c:	00 c0       	rjmp	.+0      	; 0x125e <start+0xf4>
    125e:	00 00       	nop
			_delay_ms(500);
			if(object_sequence[i]%2==0)//if the object is at even position the robot will take a turn in anticlockwise direction else in clockwise direction
    1260:	e0 91 20 02 	lds	r30, 0x0220	; 0x800220 <i>
    1264:	f0 91 21 02 	lds	r31, 0x0221	; 0x800221 <i+0x1>
    1268:	ee 0f       	add	r30, r30
    126a:	ff 1f       	adc	r31, r31
    126c:	ea 5f       	subi	r30, 0xFA	; 250
    126e:	fd 4f       	sbci	r31, 0xFD	; 253
    1270:	80 81       	ld	r24, Z
    1272:	80 fd       	sbrc	r24, 0
    1274:	04 c0       	rjmp	.+8      	; 0x127e <start+0x114>
			{
				//in this case arm will not go down as it may not support but interfere in the pickup
				rotate_clockwise(1);//robot will turn towards the object,our navigation for the first object is complete
    1276:	ce 01       	movw	r24, r28
    1278:	0e 94 c0 04 	call	0x980	; 0x980 <rotate_clockwise>
    127c:	b4 c0       	rjmp	.+360    	; 0x13e6 <start+0x27c>
//Function to rotate Servo 2 by a specified angle in the multiples of 1.86 degrees
void servo_2(unsigned char degrees)
{
	float PositionTiltServo = 0;
	PositionTiltServo = ((float)degrees / 1.86) + 35.0;
	OCR1BH = 0x00;
    127e:	f7 01       	movw	r30, r14
    1280:	10 82       	st	Z, r1
	OCR1BL = (unsigned char) PositionTiltServo;
    1282:	f8 01       	movw	r30, r16
    1284:	d0 82       	st	Z, r13
    1286:	ff ef       	ldi	r31, 0xFF	; 255
    1288:	2f e7       	ldi	r18, 0x7F	; 127
    128a:	43 e4       	ldi	r20, 0x43	; 67
    128c:	f1 50       	subi	r31, 0x01	; 1
    128e:	20 40       	sbci	r18, 0x00	; 0
    1290:	40 40       	sbci	r20, 0x00	; 0
    1292:	e1 f7       	brne	.-8      	; 0x128c <start+0x122>
    1294:	00 c0       	rjmp	.+0      	; 0x1296 <start+0x12c>
    1296:	00 00       	nop
			}
			else
			{
				servo_2(7);//arm goes down
				_delay_ms(1500);
				rotate_anticlockwise(1);//robot will turn towards the object,our navigation for the first object is complete
    1298:	ce 01       	movw	r24, r28
    129a:	0e 94 28 05 	call	0xa50	; 0xa50 <rotate_anticlockwise>
    129e:	a3 c0       	rjmp	.+326    	; 0x13e6 <start+0x27c>
		}
		else
		{
			//navigate the robot from (object_sequence[i-1])th to (object_sequence[i])th)position
			//i.e from previous position to next position
			get_back_on_track();//move the robot clockwise to ready the robot to go to the next placement sequence
    12a0:	0e 94 90 05 	call	0xb20	; 0xb20 <get_back_on_track>
			if(object_sequence[i-1]<=4 && object_sequence[i]>4 && object_sequence[i]<=8)// if previous position is less than 5 and next position is 5,6,7,8 it will be executed  
    12a4:	20 91 20 02 	lds	r18, 0x0220	; 0x800220 <i>
    12a8:	30 91 21 02 	lds	r19, 0x0221	; 0x800221 <i+0x1>
    12ac:	f9 01       	movw	r30, r18
    12ae:	ee 0f       	add	r30, r30
    12b0:	ff 1f       	adc	r31, r31
    12b2:	ec 5f       	subi	r30, 0xFC	; 252
    12b4:	fd 4f       	sbci	r31, 0xFD	; 253
    12b6:	80 81       	ld	r24, Z
    12b8:	91 81       	ldd	r25, Z+1	; 0x01
    12ba:	85 30       	cpi	r24, 0x05	; 5
    12bc:	91 05       	cpc	r25, r1
    12be:	0c f0       	brlt	.+2      	; 0x12c2 <start+0x158>
    12c0:	c3 c0       	rjmp	.+390    	; 0x1448 <start+0x2de>
    12c2:	f9 01       	movw	r30, r18
    12c4:	ee 0f       	add	r30, r30
    12c6:	ff 1f       	adc	r31, r31
    12c8:	ea 5f       	subi	r30, 0xFA	; 250
    12ca:	fd 4f       	sbci	r31, 0xFD	; 253
    12cc:	40 81       	ld	r20, Z
    12ce:	51 81       	ldd	r21, Z+1	; 0x01
    12d0:	45 30       	cpi	r20, 0x05	; 5
    12d2:	51 05       	cpc	r21, r1
    12d4:	0c f4       	brge	.+2      	; 0x12d8 <start+0x16e>
    12d6:	b0 c0       	rjmp	.+352    	; 0x1438 <start+0x2ce>
    12d8:	49 30       	cpi	r20, 0x09	; 9
    12da:	51 05       	cpc	r21, r1
    12dc:	0c f0       	brlt	.+2      	; 0x12e0 <start+0x176>
    12de:	a4 c0       	rjmp	.+328    	; 0x1428 <start+0x2be>
			{
				moveforward(calcdots(object_sequence[i-1],4)+1);
    12e0:	64 e0       	ldi	r22, 0x04	; 4
    12e2:	70 e0       	ldi	r23, 0x00	; 0
    12e4:	0e 94 04 08 	call	0x1008	; 0x1008 <calcdots>
    12e8:	01 96       	adiw	r24, 0x01	; 1
    12ea:	0e 94 41 04 	call	0x882	; 0x882 <moveforward>
				rotate_clockwise(1);
    12ee:	ce 01       	movw	r24, r28
    12f0:	0e 94 c0 04 	call	0x980	; 0x980 <rotate_clockwise>
				moveforward(calcdots(5,object_sequence[i]));
    12f4:	e0 91 20 02 	lds	r30, 0x0220	; 0x800220 <i>
    12f8:	f0 91 21 02 	lds	r31, 0x0221	; 0x800221 <i+0x1>
    12fc:	ee 0f       	add	r30, r30
    12fe:	ff 1f       	adc	r31, r31
    1300:	ea 5f       	subi	r30, 0xFA	; 250
    1302:	fd 4f       	sbci	r31, 0xFD	; 253
    1304:	60 81       	ld	r22, Z
    1306:	71 81       	ldd	r23, Z+1	; 0x01
    1308:	85 e0       	ldi	r24, 0x05	; 5
    130a:	90 e0       	ldi	r25, 0x00	; 0
    130c:	0e 94 04 08 	call	0x1008	; 0x1008 <calcdots>
    1310:	0e 94 41 04 	call	0x882	; 0x882 <moveforward>
    1314:	58 c0       	rjmp	.+176    	; 0x13c6 <start+0x25c>
			}
			else if(object_sequence[i-1]>4 && object_sequence[i-1]<=8 && object_sequence[i]>8)//if previous postion is less than 9 and next position is 9,10,11,12 it will be executed
    1316:	f9 01       	movw	r30, r18
    1318:	ee 0f       	add	r30, r30
    131a:	ff 1f       	adc	r31, r31
    131c:	ea 5f       	subi	r30, 0xFA	; 250
    131e:	fd 4f       	sbci	r31, 0xFD	; 253
    1320:	40 81       	ld	r20, Z
    1322:	51 81       	ldd	r21, Z+1	; 0x01
    1324:	49 30       	cpi	r20, 0x09	; 9
    1326:	51 05       	cpc	r21, r1
    1328:	0c f4       	brge	.+2      	; 0x132c <start+0x1c2>
    132a:	42 c0       	rjmp	.+132    	; 0x13b0 <start+0x246>
			{
				moveforward(calcdots(object_sequence[i-1],8)+1);
    132c:	68 e0       	ldi	r22, 0x08	; 8
    132e:	70 e0       	ldi	r23, 0x00	; 0
    1330:	0e 94 04 08 	call	0x1008	; 0x1008 <calcdots>
    1334:	01 96       	adiw	r24, 0x01	; 1
    1336:	0e 94 41 04 	call	0x882	; 0x882 <moveforward>
				rotate_clockwise(1);
    133a:	ce 01       	movw	r24, r28
    133c:	0e 94 c0 04 	call	0x980	; 0x980 <rotate_clockwise>
				moveforward(calcdots(9,object_sequence[i])+1);
    1340:	e0 91 20 02 	lds	r30, 0x0220	; 0x800220 <i>
    1344:	f0 91 21 02 	lds	r31, 0x0221	; 0x800221 <i+0x1>
    1348:	ee 0f       	add	r30, r30
    134a:	ff 1f       	adc	r31, r31
    134c:	ea 5f       	subi	r30, 0xFA	; 250
    134e:	fd 4f       	sbci	r31, 0xFD	; 253
    1350:	60 81       	ld	r22, Z
    1352:	71 81       	ldd	r23, Z+1	; 0x01
    1354:	89 e0       	ldi	r24, 0x09	; 9
    1356:	90 e0       	ldi	r25, 0x00	; 0
    1358:	0e 94 04 08 	call	0x1008	; 0x1008 <calcdots>
    135c:	01 96       	adiw	r24, 0x01	; 1
    135e:	0e 94 41 04 	call	0x882	; 0x882 <moveforward>
    1362:	31 c0       	rjmp	.+98     	; 0x13c6 <start+0x25c>
				
			}
			else if(object_sequence[i-1]<=4 && object_sequence[i]>8)//if previous position is less than 5 and next position is greator than 8 it will be executed
    1364:	49 30       	cpi	r20, 0x09	; 9
    1366:	51 05       	cpc	r21, r1
    1368:	1c f1       	brlt	.+70     	; 0x13b0 <start+0x246>
			{
				moveforward(calcdots(object_sequence[i-1],4)+1);
    136a:	64 e0       	ldi	r22, 0x04	; 4
    136c:	70 e0       	ldi	r23, 0x00	; 0
    136e:	0e 94 04 08 	call	0x1008	; 0x1008 <calcdots>
    1372:	01 96       	adiw	r24, 0x01	; 1
    1374:	0e 94 41 04 	call	0x882	; 0x882 <moveforward>
				rotate_clockwise(1);
    1378:	ce 01       	movw	r24, r28
    137a:	0e 94 c0 04 	call	0x980	; 0x980 <rotate_clockwise>
				moveforward(5);
    137e:	85 e0       	ldi	r24, 0x05	; 5
    1380:	90 e0       	ldi	r25, 0x00	; 0
    1382:	0e 94 41 04 	call	0x882	; 0x882 <moveforward>
				rotate_clockwise(1);
    1386:	ce 01       	movw	r24, r28
    1388:	0e 94 c0 04 	call	0x980	; 0x980 <rotate_clockwise>
				moveforward(calcdots(9,object_sequence[i])+1);
    138c:	e0 91 20 02 	lds	r30, 0x0220	; 0x800220 <i>
    1390:	f0 91 21 02 	lds	r31, 0x0221	; 0x800221 <i+0x1>
    1394:	ee 0f       	add	r30, r30
    1396:	ff 1f       	adc	r31, r31
    1398:	ea 5f       	subi	r30, 0xFA	; 250
    139a:	fd 4f       	sbci	r31, 0xFD	; 253
    139c:	60 81       	ld	r22, Z
    139e:	71 81       	ldd	r23, Z+1	; 0x01
    13a0:	89 e0       	ldi	r24, 0x09	; 9
    13a2:	90 e0       	ldi	r25, 0x00	; 0
    13a4:	0e 94 04 08 	call	0x1008	; 0x1008 <calcdots>
    13a8:	01 96       	adiw	r24, 0x01	; 1
    13aa:	0e 94 41 04 	call	0x882	; 0x882 <moveforward>
    13ae:	0b c0       	rjmp	.+22     	; 0x13c6 <start+0x25c>
				
			}
			else//for all the other cases it will be executed
			{
				moveforward(calcdots(object_sequence[i-1],object_sequence[i]));
    13b0:	22 0f       	add	r18, r18
    13b2:	33 1f       	adc	r19, r19
    13b4:	f9 01       	movw	r30, r18
    13b6:	ea 5f       	subi	r30, 0xFA	; 250
    13b8:	fd 4f       	sbci	r31, 0xFD	; 253
    13ba:	60 81       	ld	r22, Z
    13bc:	71 81       	ldd	r23, Z+1	; 0x01
    13be:	0e 94 04 08 	call	0x1008	; 0x1008 <calcdots>
    13c2:	0e 94 41 04 	call	0x882	; 0x882 <moveforward>
//Function to rotate Servo 2 by a specified angle in the multiples of 1.86 degrees
void servo_2(unsigned char degrees)
{
	float PositionTiltServo = 0;
	PositionTiltServo = ((float)degrees / 1.86) + 35.0;
	OCR1BH = 0x00;
    13c6:	f7 01       	movw	r30, r14
    13c8:	10 82       	st	Z, r1
	OCR1BL = (unsigned char) PositionTiltServo;
    13ca:	f8 01       	movw	r30, r16
    13cc:	d0 82       	st	Z, r13
    13ce:	ff ef       	ldi	r31, 0xFF	; 255
    13d0:	2f e7       	ldi	r18, 0x7F	; 127
    13d2:	43 e4       	ldi	r20, 0x43	; 67
    13d4:	f1 50       	subi	r31, 0x01	; 1
    13d6:	20 40       	sbci	r18, 0x00	; 0
    13d8:	40 40       	sbci	r20, 0x00	; 0
    13da:	e1 f7       	brne	.-8      	; 0x13d4 <start+0x26a>
    13dc:	00 c0       	rjmp	.+0      	; 0x13de <start+0x274>
    13de:	00 00       	nop
				moveforward(calcdots(object_sequence[i-1],object_sequence[i]));
				
			}
			servo_2(7);//arm goes down
			_delay_ms(1500);
			rotate_anticlockwise(1);
    13e0:	ce 01       	movw	r24, r28
    13e2:	0e 94 28 05 	call	0xa50	; 0xa50 <rotate_anticlockwise>
		}
		//pick the block and place in the (empty_current_container)th container
		pickup_and_place(empty_current_container);//picking up the object and placing it in the container
    13e6:	80 91 22 02 	lds	r24, 0x0222	; 0x800222 <empty_current_container>
    13ea:	90 91 23 02 	lds	r25, 0x0223	; 0x800223 <empty_current_container+0x1>
    13ee:	0e 94 e3 02 	call	0x5c6	; 0x5c6 <pickup_and_place>
		empty_current_container--;i++;//incrementing i for next object to reach and decrementing container as by now that position will be filled
    13f2:	20 91 22 02 	lds	r18, 0x0222	; 0x800222 <empty_current_container>
    13f6:	30 91 23 02 	lds	r19, 0x0223	; 0x800223 <empty_current_container+0x1>
    13fa:	21 50       	subi	r18, 0x01	; 1
    13fc:	31 09       	sbc	r19, r1
    13fe:	30 93 23 02 	sts	0x0223, r19	; 0x800223 <empty_current_container+0x1>
    1402:	20 93 22 02 	sts	0x0222, r18	; 0x800222 <empty_current_container>
    1406:	80 91 20 02 	lds	r24, 0x0220	; 0x800220 <i>
    140a:	90 91 21 02 	lds	r25, 0x0221	; 0x800221 <i+0x1>
    140e:	01 96       	adiw	r24, 0x01	; 1
    1410:	90 93 21 02 	sts	0x0221, r25	; 0x800221 <i+0x1>
    1414:	80 93 20 02 	sts	0x0220, r24	; 0x800220 <i>
logic:navigates the robot from start position to the next object position or form the previous object position to the next object position
Example start
*/
void start()
{
	while(i<object_sequence_length && empty_current_container!=-1)
    1418:	86 30       	cpi	r24, 0x06	; 6
    141a:	91 05       	cpc	r25, r1
    141c:	ec f4       	brge	.+58     	; 0x1458 <start+0x2ee>
    141e:	2f 3f       	cpi	r18, 0xFF	; 255
    1420:	3f 4f       	sbci	r19, 0xFF	; 255
    1422:	09 f0       	breq	.+2      	; 0x1426 <start+0x2bc>
    1424:	c6 ce       	rjmp	.-628    	; 0x11b2 <start+0x48>
    1426:	18 c0       	rjmp	.+48     	; 0x1458 <start+0x2ee>
			{
				moveforward(calcdots(object_sequence[i-1],4)+1);
				rotate_clockwise(1);
				moveforward(calcdots(5,object_sequence[i]));
			}
			else if(object_sequence[i-1]>4 && object_sequence[i-1]<=8 && object_sequence[i]>8)//if previous postion is less than 9 and next position is 9,10,11,12 it will be executed
    1428:	9c 01       	movw	r18, r24
    142a:	25 50       	subi	r18, 0x05	; 5
    142c:	31 09       	sbc	r19, r1
    142e:	24 30       	cpi	r18, 0x04	; 4
    1430:	31 05       	cpc	r19, r1
    1432:	08 f4       	brcc	.+2      	; 0x1436 <start+0x2cc>
    1434:	7b cf       	rjmp	.-266    	; 0x132c <start+0x1c2>
    1436:	99 cf       	rjmp	.-206    	; 0x136a <start+0x200>
    1438:	bc 01       	movw	r22, r24
    143a:	65 50       	subi	r22, 0x05	; 5
    143c:	71 09       	sbc	r23, r1
    143e:	64 30       	cpi	r22, 0x04	; 4
    1440:	71 05       	cpc	r23, r1
    1442:	08 f0       	brcs	.+2      	; 0x1446 <start+0x2dc>
    1444:	8f cf       	rjmp	.-226    	; 0x1364 <start+0x1fa>
    1446:	67 cf       	rjmp	.-306    	; 0x1316 <start+0x1ac>
    1448:	ac 01       	movw	r20, r24
    144a:	45 50       	subi	r20, 0x05	; 5
    144c:	51 09       	sbc	r21, r1
    144e:	44 30       	cpi	r20, 0x04	; 4
    1450:	51 05       	cpc	r21, r1
    1452:	08 f4       	brcc	.+2      	; 0x1456 <start+0x2ec>
    1454:	60 cf       	rjmp	.-320    	; 0x1316 <start+0x1ac>
    1456:	ac cf       	rjmp	.-168    	; 0x13b0 <start+0x246>
		}
		//pick the block and place in the (empty_current_container)th container
		pickup_and_place(empty_current_container);//picking up the object and placing it in the container
		empty_current_container--;i++;//incrementing i for next object to reach and decrementing container as by now that position will be filled
	}
}
    1458:	df 91       	pop	r29
    145a:	cf 91       	pop	r28
    145c:	1f 91       	pop	r17
    145e:	0f 91       	pop	r16
    1460:	ff 90       	pop	r15
    1462:	ef 90       	pop	r14
    1464:	df 90       	pop	r13
    1466:	08 95       	ret

00001468 <main>:
logic:contains the main code
Example call:called automatically when the program is executed
*/
//Main Function
int main(void)
{
    1468:	3f 92       	push	r3
    146a:	4f 92       	push	r4
    146c:	5f 92       	push	r5
    146e:	6f 92       	push	r6
    1470:	7f 92       	push	r7
    1472:	8f 92       	push	r8
    1474:	9f 92       	push	r9
    1476:	af 92       	push	r10
    1478:	bf 92       	push	r11
    147a:	cf 92       	push	r12
    147c:	df 92       	push	r13
    147e:	ef 92       	push	r14
    1480:	ff 92       	push	r15
    1482:	0f 93       	push	r16
    1484:	1f 93       	push	r17
    1486:	cf 93       	push	r28
    1488:	df 93       	push	r29
	init_devices();
    148a:	0e 94 98 02 	call	0x530	; 0x530 <init_devices>
	lcd_set_4bit();
    148e:	0e 94 95 00 	call	0x12a	; 0x12a <lcd_set_4bit>
	lcd_init();
    1492:	0e 94 fd 00 	call	0x1fa	; 0x1fa <lcd_init>
	//initializing servo motors
	
	initialize_servo();//intialize the arm for its default position
    1496:	0e 94 a9 02 	call	0x552	; 0x552 <initialize_servo>
	while(i<object_sequence_length)//i.e till all the elements are not picked
    149a:	80 91 20 02 	lds	r24, 0x0220	; 0x800220 <i>
    149e:	90 91 21 02 	lds	r25, 0x0221	; 0x800221 <i+0x1>
    14a2:	06 97       	sbiw	r24, 0x06	; 6
    14a4:	0c f0       	brlt	.+2      	; 0x14a8 <main+0x40>
    14a6:	e4 c0       	rjmp	.+456    	; 0x1670 <main+0x208>
	{
		empty_current_container=empty_containers;//specifies no. of containers empty
    14a8:	c4 e0       	ldi	r28, 0x04	; 4
    14aa:	d0 e0       	ldi	r29, 0x00	; 0
}


void velocity (unsigned char left_motor, unsigned char right_motor)
{
	OCR5AL = (unsigned char)left_motor;
    14ac:	0f 2e       	mov	r0, r31
    14ae:	f8 e2       	ldi	r31, 0x28	; 40
    14b0:	ef 2e       	mov	r14, r31
    14b2:	ff 24       	eor	r15, r15
    14b4:	f3 94       	inc	r15
    14b6:	f0 2d       	mov	r31, r0
    14b8:	0f 2e       	mov	r0, r31
    14ba:	fc ed       	ldi	r31, 0xDC	; 220
    14bc:	5f 2e       	mov	r5, r31
    14be:	f0 2d       	mov	r31, r0
	OCR5BL = (unsigned char)right_motor;
    14c0:	0a e2       	ldi	r16, 0x2A	; 42
    14c2:	11 e0       	ldi	r17, 0x01	; 1
//Function to rotate Servo 2 by a specified angle in the multiples of 1.86 degrees
void servo_2(unsigned char degrees)
{
	float PositionTiltServo = 0;
	PositionTiltServo = ((float)degrees / 1.86) + 35.0;
	OCR1BH = 0x00;
    14c4:	0f 2e       	mov	r0, r31
    14c6:	fb e8       	ldi	r31, 0x8B	; 139
    14c8:	cf 2e       	mov	r12, r31
    14ca:	d1 2c       	mov	r13, r1
    14cc:	f0 2d       	mov	r31, r0
	OCR1BL = (unsigned char) PositionTiltServo;
    14ce:	0f 2e       	mov	r0, r31
    14d0:	fa e8       	ldi	r31, 0x8A	; 138
    14d2:	8f 2e       	mov	r8, r31
    14d4:	91 2c       	mov	r9, r1
    14d6:	f0 2d       	mov	r31, r0
    14d8:	0f 2e       	mov	r0, r31
    14da:	f6 e2       	ldi	r31, 0x26	; 38
    14dc:	4f 2e       	mov	r4, r31
    14de:	f0 2d       	mov	r31, r0
					moveforward(3);//navigate to 10 position
					
				}
				else//for position 11 and 12
				{
					moveforward(12-object_sequence[i]);//navigate to 11 or 12
    14e0:	0f 2e       	mov	r0, r31
    14e2:	fc e0       	ldi	r31, 0x0C	; 12
    14e4:	af 2e       	mov	r10, r31
    14e6:	b1 2c       	mov	r11, r1
    14e8:	f0 2d       	mov	r31, r0
logic:sends the signal multiple times since it may be possible zigbee on the other hand might not recieve the signal send from here
Example call:send('A')
*/
void send(unsigned char data_to_be_sent)//function to send data
{
		UDR0=data_to_be_sent;
    14ea:	0f 2e       	mov	r0, r31
    14ec:	f6 ec       	ldi	r31, 0xC6	; 198
    14ee:	6f 2e       	mov	r6, r31
    14f0:	71 2c       	mov	r7, r1
    14f2:	f0 2d       	mov	r31, r0
    14f4:	0f 2e       	mov	r0, r31
    14f6:	f1 e3       	ldi	r31, 0x31	; 49
    14f8:	3f 2e       	mov	r3, r31
    14fa:	f0 2d       	mov	r31, r0
	//initializing servo motors
	
	initialize_servo();//intialize the arm for its default position
	while(i<object_sequence_length)//i.e till all the elements are not picked
	{
		empty_current_container=empty_containers;//specifies no. of containers empty
    14fc:	d0 93 23 02 	sts	0x0223, r29	; 0x800223 <empty_current_container+0x1>
    1500:	c0 93 22 02 	sts	0x0222, r28	; 0x800222 <empty_current_container>
		if(total_rounds!=0)//implies the robot is at starting position if total_rounds=0
    1504:	80 91 28 02 	lds	r24, 0x0228	; 0x800228 <total_rounds>
    1508:	90 91 29 02 	lds	r25, 0x0229	; 0x800229 <total_rounds+0x1>
    150c:	89 2b       	or	r24, r25
    150e:	09 f4       	brne	.+2      	; 0x1512 <main+0xaa>
    1510:	90 c0       	rjmp	.+288    	; 0x1632 <main+0x1ca>
		{
			back();
    1512:	0e 94 51 02 	call	0x4a2	; 0x4a2 <back>
}


void velocity (unsigned char left_motor, unsigned char right_motor)
{
	OCR5AL = (unsigned char)left_motor;
    1516:	f7 01       	movw	r30, r14
    1518:	50 82       	st	Z, r5
	OCR5BL = (unsigned char)right_motor;
    151a:	f8 01       	movw	r30, r16
    151c:	50 82       	st	Z, r5
		empty_current_container=empty_containers;//specifies no. of containers empty
		if(total_rounds!=0)//implies the robot is at starting position if total_rounds=0
		{
			back();
			velocity(220,220);
			linear_distance_mm(300);
    151e:	8c e2       	ldi	r24, 0x2C	; 44
    1520:	91 e0       	ldi	r25, 0x01	; 1
    1522:	0e 94 61 02 	call	0x4c2	; 0x4c2 <linear_distance_mm>
			stop();
    1526:	0e 94 5d 02 	call	0x4ba	; 0x4ba <stop>
    152a:	ff ef       	ldi	r31, 0xFF	; 255
    152c:	2f e7       	ldi	r18, 0x7F	; 127
    152e:	36 e1       	ldi	r19, 0x16	; 22
    1530:	f1 50       	subi	r31, 0x01	; 1
    1532:	20 40       	sbci	r18, 0x00	; 0
    1534:	30 40       	sbci	r19, 0x00	; 0
    1536:	e1 f7       	brne	.-8      	; 0x1530 <main+0xc8>
    1538:	00 c0       	rjmp	.+0      	; 0x153a <main+0xd2>
    153a:	00 00       	nop
			_delay_ms(500);
			//if the robot is at position 1 after placing the containers total no. of object left to pickup will be zero as bot is capable of holding more than 4 objects at a time and 1 position is specified only for first 4 objects so no is condition for position 1
			if(position_while_placing_containers_in_rotating_structure==2)
    153c:	80 91 24 02 	lds	r24, 0x0224	; 0x800224 <position_while_placing_containers_in_rotating_structure>
    1540:	90 91 25 02 	lds	r25, 0x0225	; 0x800225 <position_while_placing_containers_in_rotating_structure+0x1>
    1544:	02 97       	sbiw	r24, 0x02	; 2
    1546:	e9 f4       	brne	.+58     	; 0x1582 <main+0x11a>
			{
				rotate_clockwise(2);
    1548:	82 e0       	ldi	r24, 0x02	; 2
    154a:	90 e0       	ldi	r25, 0x00	; 0
    154c:	0e 94 c0 04 	call	0x980	; 0x980 <rotate_clockwise>
				moveforward(0);
    1550:	80 e0       	ldi	r24, 0x00	; 0
    1552:	90 e0       	ldi	r25, 0x00	; 0
    1554:	0e 94 41 04 	call	0x882	; 0x882 <moveforward>
				rotate_clockwise(4);
    1558:	ce 01       	movw	r24, r28
    155a:	0e 94 c0 04 	call	0x980	; 0x980 <rotate_clockwise>
				initialize_servo();
    155e:	0e 94 a9 02 	call	0x552	; 0x552 <initialize_servo>
    1562:	8f ef       	ldi	r24, 0xFF	; 255
    1564:	9f e7       	ldi	r25, 0x7F	; 127
    1566:	e3 e4       	ldi	r30, 0x43	; 67
    1568:	81 50       	subi	r24, 0x01	; 1
    156a:	90 40       	sbci	r25, 0x00	; 0
    156c:	e0 40       	sbci	r30, 0x00	; 0
    156e:	e1 f7       	brne	.-8      	; 0x1568 <main+0x100>
    1570:	00 c0       	rjmp	.+0      	; 0x1572 <main+0x10a>
    1572:	00 00       	nop
				_delay_ms(1500);
				//object will reach the starting position
				flag_for_starting_position=0;
    1574:	10 92 1f 02 	sts	0x021F, r1	; 0x80021f <flag_for_starting_position+0x1>
    1578:	10 92 1e 02 	sts	0x021E, r1	; 0x80021e <flag_for_starting_position>
				start();
    157c:	0e 94 b5 08 	call	0x116a	; 0x116a <start>
    1580:	5e c0       	rjmp	.+188    	; 0x163e <main+0x1d6>
			}
			else
			{
				rotate_clockwise(1);
    1582:	81 e0       	ldi	r24, 0x01	; 1
    1584:	90 e0       	ldi	r25, 0x00	; 0
    1586:	0e 94 c0 04 	call	0x980	; 0x980 <rotate_clockwise>
				moveforward(0);
    158a:	80 e0       	ldi	r24, 0x00	; 0
    158c:	90 e0       	ldi	r25, 0x00	; 0
    158e:	0e 94 41 04 	call	0x882	; 0x882 <moveforward>
				rotate_anticlockwise(1);
    1592:	81 e0       	ldi	r24, 0x01	; 1
    1594:	90 e0       	ldi	r25, 0x00	; 0
    1596:	0e 94 28 05 	call	0xa50	; 0xa50 <rotate_anticlockwise>
				//if this block is executed blocks will only be left at 10 11 and 12
				if(object_sequence[i]==10)
    159a:	e0 91 20 02 	lds	r30, 0x0220	; 0x800220 <i>
    159e:	f0 91 21 02 	lds	r31, 0x0221	; 0x800221 <i+0x1>
    15a2:	ee 0f       	add	r30, r30
    15a4:	ff 1f       	adc	r31, r31
    15a6:	ea 5f       	subi	r30, 0xFA	; 250
    15a8:	fd 4f       	sbci	r31, 0xFD	; 253
    15aa:	80 81       	ld	r24, Z
    15ac:	91 81       	ldd	r25, Z+1	; 0x01
    15ae:	8a 30       	cpi	r24, 0x0A	; 10
    15b0:	91 05       	cpc	r25, r1
    15b2:	39 f4       	brne	.+14     	; 0x15c2 <main+0x15a>
logic:sends the signal multiple times since it may be possible zigbee on the other hand might not recieve the signal send from here
Example call:send('A')
*/
void send(unsigned char data_to_be_sent)//function to send data
{
		UDR0=data_to_be_sent;
    15b4:	f3 01       	movw	r30, r6
    15b6:	30 82       	st	Z, r3
				rotate_anticlockwise(1);
				//if this block is executed blocks will only be left at 10 11 and 12
				if(object_sequence[i]==10)
				{
					send('1');
					moveforward(3);//navigate to 10 position
    15b8:	83 e0       	ldi	r24, 0x03	; 3
    15ba:	90 e0       	ldi	r25, 0x00	; 0
    15bc:	0e 94 41 04 	call	0x882	; 0x882 <moveforward>
    15c0:	06 c0       	rjmp	.+12     	; 0x15ce <main+0x166>
					
				}
				else//for position 11 and 12
				{
					moveforward(12-object_sequence[i]);//navigate to 11 or 12
    15c2:	95 01       	movw	r18, r10
    15c4:	28 1b       	sub	r18, r24
    15c6:	39 0b       	sbc	r19, r25
    15c8:	c9 01       	movw	r24, r18
    15ca:	0e 94 41 04 	call	0x882	; 0x882 <moveforward>
//Function to rotate Servo 2 by a specified angle in the multiples of 1.86 degrees
void servo_2(unsigned char degrees)
{
	float PositionTiltServo = 0;
	PositionTiltServo = ((float)degrees / 1.86) + 35.0;
	OCR1BH = 0x00;
    15ce:	f6 01       	movw	r30, r12
    15d0:	10 82       	st	Z, r1
	OCR1BL = (unsigned char) PositionTiltServo;
    15d2:	f4 01       	movw	r30, r8
    15d4:	40 82       	st	Z, r4
    15d6:	ff ef       	ldi	r31, 0xFF	; 255
    15d8:	2f e7       	ldi	r18, 0x7F	; 127
    15da:	33 e4       	ldi	r19, 0x43	; 67
    15dc:	f1 50       	subi	r31, 0x01	; 1
    15de:	20 40       	sbci	r18, 0x00	; 0
    15e0:	30 40       	sbci	r19, 0x00	; 0
    15e2:	e1 f7       	brne	.-8      	; 0x15dc <main+0x174>
    15e4:	00 c0       	rjmp	.+0      	; 0x15e6 <main+0x17e>
    15e6:	00 00       	nop
					moveforward(12-object_sequence[i]);//navigate to 11 or 12
					
				}
				servo_2(7);
				_delay_ms(1500);
				rotate_clockwise(1);
    15e8:	81 e0       	ldi	r24, 0x01	; 1
    15ea:	90 e0       	ldi	r25, 0x00	; 0
    15ec:	0e 94 c0 04 	call	0x980	; 0x980 <rotate_clockwise>
				pickup_and_place(empty_current_container);
    15f0:	80 91 22 02 	lds	r24, 0x0222	; 0x800222 <empty_current_container>
    15f4:	90 91 23 02 	lds	r25, 0x0223	; 0x800223 <empty_current_container+0x1>
    15f8:	0e 94 e3 02 	call	0x5c6	; 0x5c6 <pickup_and_place>
				empty_current_container--;i++;
    15fc:	80 91 22 02 	lds	r24, 0x0222	; 0x800222 <empty_current_container>
    1600:	90 91 23 02 	lds	r25, 0x0223	; 0x800223 <empty_current_container+0x1>
    1604:	01 97       	sbiw	r24, 0x01	; 1
    1606:	90 93 23 02 	sts	0x0223, r25	; 0x800223 <empty_current_container+0x1>
    160a:	80 93 22 02 	sts	0x0222, r24	; 0x800222 <empty_current_container>
    160e:	80 91 20 02 	lds	r24, 0x0220	; 0x800220 <i>
    1612:	90 91 21 02 	lds	r25, 0x0221	; 0x800221 <i+0x1>
    1616:	01 96       	adiw	r24, 0x01	; 1
    1618:	90 93 21 02 	sts	0x0221, r25	; 0x800221 <i+0x1>
    161c:	80 93 20 02 	sts	0x0220, r24	; 0x800220 <i>
				flag_for_starting_position=1;
    1620:	81 e0       	ldi	r24, 0x01	; 1
    1622:	90 e0       	ldi	r25, 0x00	; 0
    1624:	90 93 1f 02 	sts	0x021F, r25	; 0x80021f <flag_for_starting_position+0x1>
    1628:	80 93 1e 02 	sts	0x021E, r24	; 0x80021e <flag_for_starting_position>
				start();
    162c:	0e 94 b5 08 	call	0x116a	; 0x116a <start>
    1630:	06 c0       	rjmp	.+12     	; 0x163e <main+0x1d6>
				
			}
		}
		else
		{
			flag_for_starting_position=0;
    1632:	10 92 1f 02 	sts	0x021F, r1	; 0x80021f <flag_for_starting_position+0x1>
    1636:	10 92 1e 02 	sts	0x021E, r1	; 0x80021e <flag_for_starting_position>
			start();
    163a:	0e 94 b5 08 	call	0x116a	; 0x116a <start>
		}
		
		//return to the rotating structure
		return_rotating_structure(object_sequence[i-1]);
    163e:	e0 91 20 02 	lds	r30, 0x0220	; 0x800220 <i>
    1642:	f0 91 21 02 	lds	r31, 0x0221	; 0x800221 <i+0x1>
    1646:	ee 0f       	add	r30, r30
    1648:	ff 1f       	adc	r31, r31
    164a:	ec 5f       	subi	r30, 0xFC	; 252
    164c:	fd 4f       	sbci	r31, 0xFD	; 253
    164e:	80 81       	ld	r24, Z
    1650:	91 81       	ldd	r25, Z+1	; 0x01
    1652:	0e 94 14 08 	call	0x1028	; 0x1028 <return_rotating_structure>
		//place the objects in the rotating structure
		place_container_on_rotating_structure(empty_current_container); 
    1656:	80 91 22 02 	lds	r24, 0x0222	; 0x800222 <empty_current_container>
    165a:	90 91 23 02 	lds	r25, 0x0223	; 0x800223 <empty_current_container+0x1>
    165e:	0e 94 95 05 	call	0xb2a	; 0xb2a <place_container_on_rotating_structure>
	lcd_set_4bit();
	lcd_init();
	//initializing servo motors
	
	initialize_servo();//intialize the arm for its default position
	while(i<object_sequence_length)//i.e till all the elements are not picked
    1662:	80 91 20 02 	lds	r24, 0x0220	; 0x800220 <i>
    1666:	90 91 21 02 	lds	r25, 0x0221	; 0x800221 <i+0x1>
    166a:	06 97       	sbiw	r24, 0x06	; 6
    166c:	0c f4       	brge	.+2      	; 0x1670 <main+0x208>
    166e:	46 cf       	rjmp	.-372    	; 0x14fc <main+0x94>
		//return to the rotating structure
		return_rotating_structure(object_sequence[i-1]);
		//place the objects in the rotating structure
		place_container_on_rotating_structure(empty_current_container); 
	}
	stop();
    1670:	0e 94 5d 02 	call	0x4ba	; 0x4ba <stop>
logic:sends the signal multiple times since it may be possible zigbee on the other hand might not recieve the signal send from here
Example call:send('A')
*/
void send(unsigned char data_to_be_sent)//function to send data
{
		UDR0=data_to_be_sent;
    1674:	85 e6       	ldi	r24, 0x65	; 101
    1676:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
    167a:	8f ef       	ldi	r24, 0xFF	; 255
    167c:	9f eb       	ldi	r25, 0xBF	; 191
    167e:	e6 e0       	ldi	r30, 0x06	; 6
    1680:	81 50       	subi	r24, 0x01	; 1
    1682:	90 40       	sbci	r25, 0x00	; 0
    1684:	e0 40       	sbci	r30, 0x00	; 0
    1686:	e1 f7       	brne	.-8      	; 0x1680 <main+0x218>
    1688:	00 c0       	rjmp	.+0      	; 0x168a <main+0x222>
    168a:	00 00       	nop
		place_container_on_rotating_structure(empty_current_container); 
	}
	stop();
	send('e');
	_delay_ms(150);
	buzzer_on();
    168c:	0e 94 45 02 	call	0x48a	; 0x48a <buzzer_on>
    1690:	ff ef       	ldi	r31, 0xFF	; 255
    1692:	2f ef       	ldi	r18, 0xFF	; 255
    1694:	30 ee       	ldi	r19, 0xE0	; 224
    1696:	80 e0       	ldi	r24, 0x00	; 0
    1698:	f1 50       	subi	r31, 0x01	; 1
    169a:	20 40       	sbci	r18, 0x00	; 0
    169c:	30 40       	sbci	r19, 0x00	; 0
    169e:	80 40       	sbci	r24, 0x00	; 0
    16a0:	d9 f7       	brne	.-10     	; 0x1698 <main+0x230>
    16a2:	00 c0       	rjmp	.+0      	; 0x16a4 <main+0x23c>
    16a4:	00 00       	nop
	_delay_ms(6000);
	buzzer_off();
    16a6:	0e 94 49 02 	call	0x492	; 0x492 <buzzer_off>
    16aa:	9f ef       	ldi	r25, 0xFF	; 255
    16ac:	ef ef       	ldi	r30, 0xFF	; 255
    16ae:	fb e4       	ldi	r31, 0x4B	; 75
    16b0:	2d e1       	ldi	r18, 0x1D	; 29
    16b2:	91 50       	subi	r25, 0x01	; 1
    16b4:	e0 40       	sbci	r30, 0x00	; 0
    16b6:	f0 40       	sbci	r31, 0x00	; 0
    16b8:	20 40       	sbci	r18, 0x00	; 0
    16ba:	d9 f7       	brne	.-10     	; 0x16b2 <main+0x24a>
    16bc:	00 c0       	rjmp	.+0      	; 0x16be <main+0x256>
    16be:	00 00       	nop
	_delay_ms(200000);
	//send message to end the game
	//stop the bot
	//buzzer on for 5 seconds
	
}
    16c0:	80 e0       	ldi	r24, 0x00	; 0
    16c2:	90 e0       	ldi	r25, 0x00	; 0
    16c4:	df 91       	pop	r29
    16c6:	cf 91       	pop	r28
    16c8:	1f 91       	pop	r17
    16ca:	0f 91       	pop	r16
    16cc:	ff 90       	pop	r15
    16ce:	ef 90       	pop	r14
    16d0:	df 90       	pop	r13
    16d2:	cf 90       	pop	r12
    16d4:	bf 90       	pop	r11
    16d6:	af 90       	pop	r10
    16d8:	9f 90       	pop	r9
    16da:	8f 90       	pop	r8
    16dc:	7f 90       	pop	r7
    16de:	6f 90       	pop	r6
    16e0:	5f 90       	pop	r5
    16e2:	4f 90       	pop	r4
    16e4:	3f 90       	pop	r3
    16e6:	08 95       	ret

000016e8 <__divsf3>:
    16e8:	0e 94 88 0b 	call	0x1710	; 0x1710 <__divsf3x>
    16ec:	0c 94 69 0c 	jmp	0x18d2	; 0x18d2 <__fp_round>
    16f0:	0e 94 62 0c 	call	0x18c4	; 0x18c4 <__fp_pscB>
    16f4:	58 f0       	brcs	.+22     	; 0x170c <__divsf3+0x24>
    16f6:	0e 94 5b 0c 	call	0x18b6	; 0x18b6 <__fp_pscA>
    16fa:	40 f0       	brcs	.+16     	; 0x170c <__divsf3+0x24>
    16fc:	29 f4       	brne	.+10     	; 0x1708 <__divsf3+0x20>
    16fe:	5f 3f       	cpi	r21, 0xFF	; 255
    1700:	29 f0       	breq	.+10     	; 0x170c <__divsf3+0x24>
    1702:	0c 94 52 0c 	jmp	0x18a4	; 0x18a4 <__fp_inf>
    1706:	51 11       	cpse	r21, r1
    1708:	0c 94 9d 0c 	jmp	0x193a	; 0x193a <__fp_szero>
    170c:	0c 94 58 0c 	jmp	0x18b0	; 0x18b0 <__fp_nan>

00001710 <__divsf3x>:
    1710:	0e 94 7a 0c 	call	0x18f4	; 0x18f4 <__fp_split3>
    1714:	68 f3       	brcs	.-38     	; 0x16f0 <__divsf3+0x8>

00001716 <__divsf3_pse>:
    1716:	99 23       	and	r25, r25
    1718:	b1 f3       	breq	.-20     	; 0x1706 <__divsf3+0x1e>
    171a:	55 23       	and	r21, r21
    171c:	91 f3       	breq	.-28     	; 0x1702 <__divsf3+0x1a>
    171e:	95 1b       	sub	r25, r21
    1720:	55 0b       	sbc	r21, r21
    1722:	bb 27       	eor	r27, r27
    1724:	aa 27       	eor	r26, r26
    1726:	62 17       	cp	r22, r18
    1728:	73 07       	cpc	r23, r19
    172a:	84 07       	cpc	r24, r20
    172c:	38 f0       	brcs	.+14     	; 0x173c <__divsf3_pse+0x26>
    172e:	9f 5f       	subi	r25, 0xFF	; 255
    1730:	5f 4f       	sbci	r21, 0xFF	; 255
    1732:	22 0f       	add	r18, r18
    1734:	33 1f       	adc	r19, r19
    1736:	44 1f       	adc	r20, r20
    1738:	aa 1f       	adc	r26, r26
    173a:	a9 f3       	breq	.-22     	; 0x1726 <__divsf3_pse+0x10>
    173c:	35 d0       	rcall	.+106    	; 0x17a8 <__divsf3_pse+0x92>
    173e:	0e 2e       	mov	r0, r30
    1740:	3a f0       	brmi	.+14     	; 0x1750 <__divsf3_pse+0x3a>
    1742:	e0 e8       	ldi	r30, 0x80	; 128
    1744:	32 d0       	rcall	.+100    	; 0x17aa <__divsf3_pse+0x94>
    1746:	91 50       	subi	r25, 0x01	; 1
    1748:	50 40       	sbci	r21, 0x00	; 0
    174a:	e6 95       	lsr	r30
    174c:	00 1c       	adc	r0, r0
    174e:	ca f7       	brpl	.-14     	; 0x1742 <__divsf3_pse+0x2c>
    1750:	2b d0       	rcall	.+86     	; 0x17a8 <__divsf3_pse+0x92>
    1752:	fe 2f       	mov	r31, r30
    1754:	29 d0       	rcall	.+82     	; 0x17a8 <__divsf3_pse+0x92>
    1756:	66 0f       	add	r22, r22
    1758:	77 1f       	adc	r23, r23
    175a:	88 1f       	adc	r24, r24
    175c:	bb 1f       	adc	r27, r27
    175e:	26 17       	cp	r18, r22
    1760:	37 07       	cpc	r19, r23
    1762:	48 07       	cpc	r20, r24
    1764:	ab 07       	cpc	r26, r27
    1766:	b0 e8       	ldi	r27, 0x80	; 128
    1768:	09 f0       	breq	.+2      	; 0x176c <__divsf3_pse+0x56>
    176a:	bb 0b       	sbc	r27, r27
    176c:	80 2d       	mov	r24, r0
    176e:	bf 01       	movw	r22, r30
    1770:	ff 27       	eor	r31, r31
    1772:	93 58       	subi	r25, 0x83	; 131
    1774:	5f 4f       	sbci	r21, 0xFF	; 255
    1776:	3a f0       	brmi	.+14     	; 0x1786 <__divsf3_pse+0x70>
    1778:	9e 3f       	cpi	r25, 0xFE	; 254
    177a:	51 05       	cpc	r21, r1
    177c:	78 f0       	brcs	.+30     	; 0x179c <__divsf3_pse+0x86>
    177e:	0c 94 52 0c 	jmp	0x18a4	; 0x18a4 <__fp_inf>
    1782:	0c 94 9d 0c 	jmp	0x193a	; 0x193a <__fp_szero>
    1786:	5f 3f       	cpi	r21, 0xFF	; 255
    1788:	e4 f3       	brlt	.-8      	; 0x1782 <__divsf3_pse+0x6c>
    178a:	98 3e       	cpi	r25, 0xE8	; 232
    178c:	d4 f3       	brlt	.-12     	; 0x1782 <__divsf3_pse+0x6c>
    178e:	86 95       	lsr	r24
    1790:	77 95       	ror	r23
    1792:	67 95       	ror	r22
    1794:	b7 95       	ror	r27
    1796:	f7 95       	ror	r31
    1798:	9f 5f       	subi	r25, 0xFF	; 255
    179a:	c9 f7       	brne	.-14     	; 0x178e <__divsf3_pse+0x78>
    179c:	88 0f       	add	r24, r24
    179e:	91 1d       	adc	r25, r1
    17a0:	96 95       	lsr	r25
    17a2:	87 95       	ror	r24
    17a4:	97 f9       	bld	r25, 7
    17a6:	08 95       	ret
    17a8:	e1 e0       	ldi	r30, 0x01	; 1
    17aa:	66 0f       	add	r22, r22
    17ac:	77 1f       	adc	r23, r23
    17ae:	88 1f       	adc	r24, r24
    17b0:	bb 1f       	adc	r27, r27
    17b2:	62 17       	cp	r22, r18
    17b4:	73 07       	cpc	r23, r19
    17b6:	84 07       	cpc	r24, r20
    17b8:	ba 07       	cpc	r27, r26
    17ba:	20 f0       	brcs	.+8      	; 0x17c4 <__divsf3_pse+0xae>
    17bc:	62 1b       	sub	r22, r18
    17be:	73 0b       	sbc	r23, r19
    17c0:	84 0b       	sbc	r24, r20
    17c2:	ba 0b       	sbc	r27, r26
    17c4:	ee 1f       	adc	r30, r30
    17c6:	88 f7       	brcc	.-30     	; 0x17aa <__divsf3_pse+0x94>
    17c8:	e0 95       	com	r30
    17ca:	08 95       	ret

000017cc <__fixunssfsi>:
    17cc:	0e 94 82 0c 	call	0x1904	; 0x1904 <__fp_splitA>
    17d0:	88 f0       	brcs	.+34     	; 0x17f4 <__fixunssfsi+0x28>
    17d2:	9f 57       	subi	r25, 0x7F	; 127
    17d4:	98 f0       	brcs	.+38     	; 0x17fc <__fixunssfsi+0x30>
    17d6:	b9 2f       	mov	r27, r25
    17d8:	99 27       	eor	r25, r25
    17da:	b7 51       	subi	r27, 0x17	; 23
    17dc:	b0 f0       	brcs	.+44     	; 0x180a <__fixunssfsi+0x3e>
    17de:	e1 f0       	breq	.+56     	; 0x1818 <__fixunssfsi+0x4c>
    17e0:	66 0f       	add	r22, r22
    17e2:	77 1f       	adc	r23, r23
    17e4:	88 1f       	adc	r24, r24
    17e6:	99 1f       	adc	r25, r25
    17e8:	1a f0       	brmi	.+6      	; 0x17f0 <__fixunssfsi+0x24>
    17ea:	ba 95       	dec	r27
    17ec:	c9 f7       	brne	.-14     	; 0x17e0 <__fixunssfsi+0x14>
    17ee:	14 c0       	rjmp	.+40     	; 0x1818 <__fixunssfsi+0x4c>
    17f0:	b1 30       	cpi	r27, 0x01	; 1
    17f2:	91 f0       	breq	.+36     	; 0x1818 <__fixunssfsi+0x4c>
    17f4:	0e 94 9c 0c 	call	0x1938	; 0x1938 <__fp_zero>
    17f8:	b1 e0       	ldi	r27, 0x01	; 1
    17fa:	08 95       	ret
    17fc:	0c 94 9c 0c 	jmp	0x1938	; 0x1938 <__fp_zero>
    1800:	67 2f       	mov	r22, r23
    1802:	78 2f       	mov	r23, r24
    1804:	88 27       	eor	r24, r24
    1806:	b8 5f       	subi	r27, 0xF8	; 248
    1808:	39 f0       	breq	.+14     	; 0x1818 <__fixunssfsi+0x4c>
    180a:	b9 3f       	cpi	r27, 0xF9	; 249
    180c:	cc f3       	brlt	.-14     	; 0x1800 <__fixunssfsi+0x34>
    180e:	86 95       	lsr	r24
    1810:	77 95       	ror	r23
    1812:	67 95       	ror	r22
    1814:	b3 95       	inc	r27
    1816:	d9 f7       	brne	.-10     	; 0x180e <__fixunssfsi+0x42>
    1818:	3e f4       	brtc	.+14     	; 0x1828 <__fixunssfsi+0x5c>
    181a:	90 95       	com	r25
    181c:	80 95       	com	r24
    181e:	70 95       	com	r23
    1820:	61 95       	neg	r22
    1822:	7f 4f       	sbci	r23, 0xFF	; 255
    1824:	8f 4f       	sbci	r24, 0xFF	; 255
    1826:	9f 4f       	sbci	r25, 0xFF	; 255
    1828:	08 95       	ret

0000182a <__floatunsisf>:
    182a:	e8 94       	clt
    182c:	09 c0       	rjmp	.+18     	; 0x1840 <__floatsisf+0x12>

0000182e <__floatsisf>:
    182e:	97 fb       	bst	r25, 7
    1830:	3e f4       	brtc	.+14     	; 0x1840 <__floatsisf+0x12>
    1832:	90 95       	com	r25
    1834:	80 95       	com	r24
    1836:	70 95       	com	r23
    1838:	61 95       	neg	r22
    183a:	7f 4f       	sbci	r23, 0xFF	; 255
    183c:	8f 4f       	sbci	r24, 0xFF	; 255
    183e:	9f 4f       	sbci	r25, 0xFF	; 255
    1840:	99 23       	and	r25, r25
    1842:	a9 f0       	breq	.+42     	; 0x186e <__floatsisf+0x40>
    1844:	f9 2f       	mov	r31, r25
    1846:	96 e9       	ldi	r25, 0x96	; 150
    1848:	bb 27       	eor	r27, r27
    184a:	93 95       	inc	r25
    184c:	f6 95       	lsr	r31
    184e:	87 95       	ror	r24
    1850:	77 95       	ror	r23
    1852:	67 95       	ror	r22
    1854:	b7 95       	ror	r27
    1856:	f1 11       	cpse	r31, r1
    1858:	f8 cf       	rjmp	.-16     	; 0x184a <__floatsisf+0x1c>
    185a:	fa f4       	brpl	.+62     	; 0x189a <__floatsisf+0x6c>
    185c:	bb 0f       	add	r27, r27
    185e:	11 f4       	brne	.+4      	; 0x1864 <__floatsisf+0x36>
    1860:	60 ff       	sbrs	r22, 0
    1862:	1b c0       	rjmp	.+54     	; 0x189a <__floatsisf+0x6c>
    1864:	6f 5f       	subi	r22, 0xFF	; 255
    1866:	7f 4f       	sbci	r23, 0xFF	; 255
    1868:	8f 4f       	sbci	r24, 0xFF	; 255
    186a:	9f 4f       	sbci	r25, 0xFF	; 255
    186c:	16 c0       	rjmp	.+44     	; 0x189a <__floatsisf+0x6c>
    186e:	88 23       	and	r24, r24
    1870:	11 f0       	breq	.+4      	; 0x1876 <__floatsisf+0x48>
    1872:	96 e9       	ldi	r25, 0x96	; 150
    1874:	11 c0       	rjmp	.+34     	; 0x1898 <__floatsisf+0x6a>
    1876:	77 23       	and	r23, r23
    1878:	21 f0       	breq	.+8      	; 0x1882 <__floatsisf+0x54>
    187a:	9e e8       	ldi	r25, 0x8E	; 142
    187c:	87 2f       	mov	r24, r23
    187e:	76 2f       	mov	r23, r22
    1880:	05 c0       	rjmp	.+10     	; 0x188c <__floatsisf+0x5e>
    1882:	66 23       	and	r22, r22
    1884:	71 f0       	breq	.+28     	; 0x18a2 <__floatsisf+0x74>
    1886:	96 e8       	ldi	r25, 0x86	; 134
    1888:	86 2f       	mov	r24, r22
    188a:	70 e0       	ldi	r23, 0x00	; 0
    188c:	60 e0       	ldi	r22, 0x00	; 0
    188e:	2a f0       	brmi	.+10     	; 0x189a <__floatsisf+0x6c>
    1890:	9a 95       	dec	r25
    1892:	66 0f       	add	r22, r22
    1894:	77 1f       	adc	r23, r23
    1896:	88 1f       	adc	r24, r24
    1898:	da f7       	brpl	.-10     	; 0x1890 <__floatsisf+0x62>
    189a:	88 0f       	add	r24, r24
    189c:	96 95       	lsr	r25
    189e:	87 95       	ror	r24
    18a0:	97 f9       	bld	r25, 7
    18a2:	08 95       	ret

000018a4 <__fp_inf>:
    18a4:	97 f9       	bld	r25, 7
    18a6:	9f 67       	ori	r25, 0x7F	; 127
    18a8:	80 e8       	ldi	r24, 0x80	; 128
    18aa:	70 e0       	ldi	r23, 0x00	; 0
    18ac:	60 e0       	ldi	r22, 0x00	; 0
    18ae:	08 95       	ret

000018b0 <__fp_nan>:
    18b0:	9f ef       	ldi	r25, 0xFF	; 255
    18b2:	80 ec       	ldi	r24, 0xC0	; 192
    18b4:	08 95       	ret

000018b6 <__fp_pscA>:
    18b6:	00 24       	eor	r0, r0
    18b8:	0a 94       	dec	r0
    18ba:	16 16       	cp	r1, r22
    18bc:	17 06       	cpc	r1, r23
    18be:	18 06       	cpc	r1, r24
    18c0:	09 06       	cpc	r0, r25
    18c2:	08 95       	ret

000018c4 <__fp_pscB>:
    18c4:	00 24       	eor	r0, r0
    18c6:	0a 94       	dec	r0
    18c8:	12 16       	cp	r1, r18
    18ca:	13 06       	cpc	r1, r19
    18cc:	14 06       	cpc	r1, r20
    18ce:	05 06       	cpc	r0, r21
    18d0:	08 95       	ret

000018d2 <__fp_round>:
    18d2:	09 2e       	mov	r0, r25
    18d4:	03 94       	inc	r0
    18d6:	00 0c       	add	r0, r0
    18d8:	11 f4       	brne	.+4      	; 0x18de <__fp_round+0xc>
    18da:	88 23       	and	r24, r24
    18dc:	52 f0       	brmi	.+20     	; 0x18f2 <__fp_round+0x20>
    18de:	bb 0f       	add	r27, r27
    18e0:	40 f4       	brcc	.+16     	; 0x18f2 <__fp_round+0x20>
    18e2:	bf 2b       	or	r27, r31
    18e4:	11 f4       	brne	.+4      	; 0x18ea <__fp_round+0x18>
    18e6:	60 ff       	sbrs	r22, 0
    18e8:	04 c0       	rjmp	.+8      	; 0x18f2 <__fp_round+0x20>
    18ea:	6f 5f       	subi	r22, 0xFF	; 255
    18ec:	7f 4f       	sbci	r23, 0xFF	; 255
    18ee:	8f 4f       	sbci	r24, 0xFF	; 255
    18f0:	9f 4f       	sbci	r25, 0xFF	; 255
    18f2:	08 95       	ret

000018f4 <__fp_split3>:
    18f4:	57 fd       	sbrc	r21, 7
    18f6:	90 58       	subi	r25, 0x80	; 128
    18f8:	44 0f       	add	r20, r20
    18fa:	55 1f       	adc	r21, r21
    18fc:	59 f0       	breq	.+22     	; 0x1914 <__fp_splitA+0x10>
    18fe:	5f 3f       	cpi	r21, 0xFF	; 255
    1900:	71 f0       	breq	.+28     	; 0x191e <__fp_splitA+0x1a>
    1902:	47 95       	ror	r20

00001904 <__fp_splitA>:
    1904:	88 0f       	add	r24, r24
    1906:	97 fb       	bst	r25, 7
    1908:	99 1f       	adc	r25, r25
    190a:	61 f0       	breq	.+24     	; 0x1924 <__fp_splitA+0x20>
    190c:	9f 3f       	cpi	r25, 0xFF	; 255
    190e:	79 f0       	breq	.+30     	; 0x192e <__fp_splitA+0x2a>
    1910:	87 95       	ror	r24
    1912:	08 95       	ret
    1914:	12 16       	cp	r1, r18
    1916:	13 06       	cpc	r1, r19
    1918:	14 06       	cpc	r1, r20
    191a:	55 1f       	adc	r21, r21
    191c:	f2 cf       	rjmp	.-28     	; 0x1902 <__fp_split3+0xe>
    191e:	46 95       	lsr	r20
    1920:	f1 df       	rcall	.-30     	; 0x1904 <__fp_splitA>
    1922:	08 c0       	rjmp	.+16     	; 0x1934 <__fp_splitA+0x30>
    1924:	16 16       	cp	r1, r22
    1926:	17 06       	cpc	r1, r23
    1928:	18 06       	cpc	r1, r24
    192a:	99 1f       	adc	r25, r25
    192c:	f1 cf       	rjmp	.-30     	; 0x1910 <__fp_splitA+0xc>
    192e:	86 95       	lsr	r24
    1930:	71 05       	cpc	r23, r1
    1932:	61 05       	cpc	r22, r1
    1934:	08 94       	sec
    1936:	08 95       	ret

00001938 <__fp_zero>:
    1938:	e8 94       	clt

0000193a <__fp_szero>:
    193a:	bb 27       	eor	r27, r27
    193c:	66 27       	eor	r22, r22
    193e:	77 27       	eor	r23, r23
    1940:	cb 01       	movw	r24, r22
    1942:	97 f9       	bld	r25, 7
    1944:	08 95       	ret

00001946 <_exit>:
    1946:	f8 94       	cli

00001948 <__stop_program>:
    1948:	ff cf       	rjmp	.-2      	; 0x1948 <__stop_program>
